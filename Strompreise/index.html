<!--
 * ============================================================================
 * Intelligente Strompreis-Optimierung - v1.0.0
 * ============================================================================
 * 
 * LIZENZINFORMATIONEN:
 * 
 * Copyright (c) 2025 by Friedhelm Koch
 * 
 * Dieses Werk ist lizenziert unter einer 
 * Creative Commons Namensnennung - Nicht kommerziell - Keine Weitergabe und Bearbeitung
 * 
 * Vollst√§ndiger Lizenztext: https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.de
 * Mensch-lesbare Zusammenfassung: https://creativecommons.org/licenses/by-nc-sa/4.0/deed.de
 * 
 * ============================================================================
 * 
 * Bedingungen der CC BY-NC-ND 4.0 Lizenz:
 * 
 * - NAMENSNENNUNG ‚Äî Sie m√ºssen angemessene Urheber- und Rechteangaben machen
 * - NICHT KOMMERZIELL ‚Äî Sie d√ºrfen das Material nicht f√ºr kommerzielle Zwecke nutzen
 * - KEINE WEITERGABE UNTER GLEICHEN BEDINGUNGEN ‚Äî Wenn Sie das Material remixen, ver√§ndern
 *   oder darauf aufbauen, d√ºrfen Sie Ihre Beitr√§ge nicht unter der gleichen Lizenz
 *   wie das Original verbreiten
 * 
 * ============================================================================
 *
 * Die Web-App erzeugt simulierte Preisdaten, die:
 * Typischen EPEX-Day-Ahead-Mustern folgen
 * Wochentage vs. Wochenende unterscheiden
 * Wettereinfl√ºsse ber√ºcksichtigen
 * Zuf√§llige Variationen haben
 * Basierend auf den Einstellungen (Wochentag, Wetter) generiert werden
 *
 * ============================================================================
 * 
 * Die echten EPEX-Spot Daten werden √ºber die API von SmartENERGY geladen
 * siehe auch: https://www.smartenergy.at/api-schnittstellen und https://apis.smartenergy.at/market/v1/price in loaddata() 
 *
 -->

<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° Intelligente Strompreis-Optimierung</title>
    <style>
        /* Mobile-First Design - nur minimal angepasst */
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        }
        
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            padding: 10px;
        }
        
        .container { 
            max-width: 100%;
            width: 100%;
            margin: 0 auto; 
            background: rgba(255,255,255,0.98); 
            border-radius: 15px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            overflow: hidden;
        }
        
        header { 
            background: linear-gradient(135deg, #00b894 0%, #0984e3 100%); 
            color: white; 
            padding: 20px 15px; 
            text-align: center; 
        }
        
        h1 { 
            font-size: 1.5rem; 
            margin-bottom: 8px; 
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            line-height: 1.3;
        }
        
        /* Hauptlayout f√ºr Mobile */
        .dashboard { 
            padding: 15px; 
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* F√ºr gr√∂√üere Screens */
        @media (min-width: 900px) {
            .container {
                max-width: 900px;
            }
            
            .dashboard {
                display: grid;
                grid-template-columns: 1fr 320px;
                gap: 20px;
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            header {
                padding: 25px;
            }
        }
        
        /* Control Panel bleibt gleich - nur Breite angepasst */
        .control-panel { 
            background: #f8f9fa; 
            padding: 20px; 
            border-radius: 12px; 
            border: 2px solid #e9ecef; 
        }
        
        .control-group { 
            margin-bottom: 15px; 
        }
        
        .control-group label { 
            display: block; 
            margin-bottom: 6px; 
            font-weight: 600; 
            color: #495057; 
        }
        
        .control-group input, 
        .control-group select { 
            width: 100%; 
            padding: 10px; 
            border: 2px solid #dee2e6; 
            border-radius: 8px; 
            font-size: 16px; 
        }
        
        .slider-container { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        
        .slider-container input[type="range"] { 
            flex: 1; 
        }
        
        .slider-value { 
            min-width: 55px; 
            text-align: center; 
            font-weight: bold; 
            color: #0984e3; 
        }
        
        /* Stats Grid angepasst f√ºr Mobile */
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 10px; 
            margin: 15px 0; 
        }
        
        @media (min-width: 480px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .stat-item { 
            background: white; 
            padding: 15px; 
            border-radius: 10px; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); 
            text-align: center; 
            border-top: 4px solid #00b894; 
        }
        
        .stat-value { 
            font-size: 1.3rem; 
            font-weight: bold; 
            color: #2d3436; 
            margin: 8px 0; 
        }
        
        /* Charts angepasst */
        .chart-container { 
            height: 250px; 
            margin: 15px 0; 
        }
        
        @media (min-width: 900px) {
            .chart-container {
                height: 280px;
            }
        }
        
        /* Buttons */
        button { 
            padding: 12px 20px; 
            background: #00b894; 
            color: white; 
            border: none; 
            border-radius: 8px; 
            font-size: 16px; 
            font-weight: 600; 
            cursor: pointer; 
            transition: all 0.3s; 
        }
        
        button:hover { 
            background: #00a085; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0,184,148,0.3); 
        }
        
        .btn-group { 
            display: flex; 
            flex-wrap: wrap;
            gap: 8px; 
            margin: 15px 0; 
        }
        
        .btn-group button {
            flex: 1;
            min-width: calc(50% - 4px);
        }
        
        /* Tab Navigation angepasst */
        .tab-container { 
            margin: 15px 0; 
        }
        
        .tab-buttons { 
            display: flex; 
            flex-wrap: wrap;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        
        .tab-button { 
            flex: 1;
            min-width: calc(33.333% - 4px);
            padding: 10px 5px; 
            background: #acd08b; 
            border: none; 
            border-radius: 6px 6px 0 0; 
            cursor: pointer; 
            font-size: 0.85rem;
        }
        
        .tab-button.active { 
            background: #00b894; 
            color: white; 
        }
        
        .tab-content { 
            background: white; 
            padding: 15px; 
            border-radius: 0 6px 6px 6px; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); 
        }
        
        /* Bestehende Styles beibehalten */
        .price-table { 
            width: 100%; 
            background: white; 
            border-radius: 10px; 
            overflow: hidden; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); 
            margin: 15px 0; 
            font-size: 0.9rem;
        }
        
        .price-table th { 
            background: #00b894; 
            color: white; 
            padding: 12px 10px; 
            text-align: left; 
        }
        
        .price-table td { 
            padding: 10px; 
            border-bottom: 1px solid #f1f2f6; 
        }
        
        .battery-section { 
            background: #2d3436; 
            padding: 15px; 
            border-radius: 10px; 
            color: white; 
            margin: 15px 0; 
        }
        
        .battery-level { 
            height: 25px; 
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71); 
            border-radius: 12px; 
            overflow: hidden; 
            margin: 10px 0; 
        }
        
        .battery-fill { 
            height: 100%; 
            background: #00b894; 
            transition: width 0.5s; 
        }
        
        .consumption-profile { 
            background: white; 
            padding: 15px; 
            border-radius: 10px; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); 
            margin: 15px 0; 
        }
        
        .recommendation-card { 
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%); 
            color: white; 
            padding: 20px; 
            border-radius: 12px; 
            margin-top: 20px; 
        }
        
        .data-source { 
            background: #fff3cd; 
            color: #856404; 
            padding: 15px; 
            margin: 15px 0; 
            border-radius: 10px; 
            text-align: center; 
        }
        
        .loading, .error, .info, .success { 
            padding: 15px; 
            margin: 15px 0; 
            border-radius: 10px; 
            text-align: center; 
        }
        
        .loading { background: #fff3cd; color: #856404; }
        .error { background: #ff6b6b; color: white; }
        .info { background: #4ecdc4; color: white; }
        .success { background: #e8f5e9; color: #2e7d32; }
        
        .optimization-results { 
            background: white; 
            padding: 15px; 
            border-radius: 10px; 
            margin: 15px 0; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); 
        }
        
        .result-item { 
            display: flex; 
            justify-content: space-between; 
            padding: 8px 0; 
            border-bottom: 1px solid #eee; 
        }
        
        .result-item:last-child { 
            border-bottom: none; 
        }
        
        .result-label { 
            font-weight: 600; 
        }
        
        .result-value { 
            font-weight: bold; 
            color: #00b894; 
        }
        
        .progress-bar { 
            height: 16px; 
            background: #e9ecef; 
            border-radius: 8px; 
            overflow: hidden; 
            margin: 10px 0; 
        }
        
        .progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #00b894, #0984e3); 
            transition: width 0.5s; 
        }
        
        /* Kleinere Anpassungen f√ºr sehr kleine Screens */
        @media (max-width: 360px) {
            .stat-item {
                padding: 10px;
            }
            
            .stat-value {
                font-size: 1.1rem;
            }
            
            .tab-button {
                font-size: 0.75rem;
                padding: 8px 3px;
            }
        }

        /* KI-Prognose spezifische Stile */
        #tab-forecast .stat-item {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #tab-forecast .stat-value {
            font-size: 1.3rem;
            margin: 8px 0;
        }

        /* Wetter-Icons */
        .weather-icon {
            font-size: 1.2rem;
            margin-right: 5px;
        }

        /* KI-Modell Status */
        .model-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            display: inline-block;
        }

        .model-status.trained {
            background: #d4edda;
            color: #155724;
        }

        .model-status.training {
            background: #fff3cd;
            color: #856404;
        }

        .model-status.ready {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* Prognose-Karte */
        .forecast-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
            border-left: 4px solid #9b59b6;
        }

        /* Responsive Anpassungen f√ºr KI-Tab */
        @media (max-width: 768px) {
            #tab-forecast .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #tab-forecast .stat-value {
                font-size: 1.1rem;
            }
        }

        @media (max-width: 480px) {
            #tab-forecast .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .tab-button {
                font-size: 0.8rem;
                padding: 8px 5px;
            }
        }

        /* Training-Status Modal */
        .training-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow-y: auto;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        .training-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-height: 90vh;
            overflow-y: auto;
        }

        /* F√ºr sehr kleine Screens */
        @media (max-width: 480px) {
            .training-modal {
                padding: 10px;
            }
            
            .training-content {
                padding: 15px;
                border-radius: 10px;
                max-height: 85vh;
            }
        }

        /* F√ºr iPhones (kleine H√∂he) */
        @media (max-height: 700px) {
            .training-content {
                max-height: 80vh;
            }
        }

        .training-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .training-header h3 {
            color: #2d3436;
            margin: 0;
            font-size: 1.2rem;
        }

        .training-spinner {
            font-size: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .training-progress-container {
            background: #e9ecef;
            border-radius: 10px;
            height: 10px;
            margin: 15px 0;
            overflow: hidden;
        }

        .training-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00b894, #0984e3);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .training-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        @media (max-width: 350px) {
            .training-stats {
                grid-template-columns: 1fr;
            }
        }

        .training-stat {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .training-stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }

        .training-stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #0984e3;
        }

        .training-status-text {
            text-align: center;
            margin: 10px 0;
            font-size: 0.95rem;
        }

        .training-detail-text {
            text-align: center;
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
            min-height: 20px;
        }

        /* Optional: Mini-Chart f√ºr Mobile (einfacher) */
        .training-mini-chart {
            height: 80px;
            margin: 15px 0;
            position: relative;
        }

        .training-chart-bar {
            position: absolute;
            bottom: 0;
            background: #00b894;
            border-radius: 3px 3px 0 0;
            transition: all 0.3s ease;
        }

        .training-logs-container {
            max-height: 120px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            border: 1px solid #e9ecef;
        }

        .training-log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
            line-height: 1.3;
            font-size: 0.75rem;
        }

        .training-log-entry:last-child {
            border-bottom: none;
        }

        .training-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .training-button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            min-width: 120px;
        }

        @media (max-width: 480px) {
            .training-button {
                min-width: 100%;
                margin-bottom: 8px;
            }
            
            .training-buttons {
                flex-direction: column;
            }
        }

        .training-button-cancel {
            background: #e74c3c;
            color: white;
        }

        .training-button-background {
            background: #7f8c8d;
            color: white;
        }

        .training-button-close {
            background: #3498db;
            color: white;
        }

        /* Close Button oben rechts */
        .training-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #666;
            cursor: pointer;
            z-index: 10;
        }

        .training-close-btn:hover {
            color: #e74c3c;
        }

        /* Scrollbar Styling f√ºr Mobile */
        .training-logs-container::-webkit-scrollbar {
            width: 6px;
        }

        .training-logs-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .training-logs-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .training-logs-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .forecast-status {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .forecast-status.simulated {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }

        .forecast-status.trained {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .forecast-status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }

        .forecast-day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .forecast-price-tag {
            background: white;
            color: #667eea;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° Intelligente Strompreis-Optimierung</h1>
            <p style="font-size: 0.9rem;">Optimale Nutzungszeiten mittels KI-Prognosen f√ºr Haushaltsger√§te & Akkus</p>
        </header>
        
        <div class="dashboard">
            <div>
                <div class="info">
                    <strong>üìä Echtzeit KI-Analyse:</strong> Vergleich von Strompreisen √ºber Wetterdaten mit Ihrem Verbrauchsprofil
                </div>
                
                <div class="data-source">
                    <strong>üìà Datenquelle:</strong> Preise basieren auf aktuellen Day-Ahead-Daten der Stromb√∂rse EPEX SPOT, sowie den aktuellen Wetterdaten und einer KI Prognose.
                    <div style="margin-top: 5px; font-size: 0.85em;">
                        Preismuster: Nachts ‚Üì, Morgens ‚Üë, Abends ‚Üë‚Üë, Wochenende ‚Üì, Sonne/Wind ‚Üì
                    </div>
                </div>
                
                <div class="tab-container">
                    <div class="tab-buttons">
                        <button class="tab-button active" onclick="showTab('prices')">Preise</button>
                        <button class="tab-button" onclick="showTab('consumption')">Verbrauch</button>
                        <button class="tab-button" onclick="showTab('comparison')">Vergleich</button>
                        <button class="tab-button" onclick="showTab('savings')">Ersparnis</button>
                        <button class="tab-button" onclick="showTab('optimization')">Optimierung</button>
                        <button class="tab-button" onclick="showTab('forecast')">KI-Prognose</button>
                    </div>
                    
                    <div id="tab-prices" class="tab-content">
                        <div class="btn-group">
                            <button onclick="loadData('today')">Heute</button>
                            <button onclick="loadData('tomorrow')">Morgen</button>
                            <button onclick="loadData('yesterday')">Gestern</button>
                        </div>
                        
                        <div class="chart-container">
                            <canvas id="priceChart"></canvas>
                        </div>
                        
                        <div class="price-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Uhrzeit</th>
                                        <th>Preis (ct/kWh)</th>
                                        <th>vs. Durchschnitt</th>
                                        <th>Empfehlung</th>
                                    </tr>
                                </thead>
                                <tbody id="priceTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div id="tab-consumption" class="tab-content" style="display: none;">
                        <h3>üè† Ihr typisches Verbrauchsprofil</h3>
                        <div class="consumption-profile">
                            <div class="chart-container">
                                <canvas id="consumptionChart"></canvas>
                            </div>
                            
                            <div style="margin-top: 20px;">
                                <h4>Verbrauchszeiten anpassen (kW):</h4>
                                <div class="control-group">
                                    <label>üåÖ Morgens (06:00-09:00) - Kaffee, Duschen, Fr√ºhst√ºck</label>
                                    <div class="slider-container">
                                        <input type="range" id="morningConsumption" min="0" max="5" value="2" step="0.5">
                                        <span class="slider-value" id="morningValue">2.0 kW</span>
                                    </div>
                                </div>
                                
                                <div class="control-group">
                                    <label>üèôÔ∏è Tags√ºber (09:00-17:00) - Home Office, K√ºhlschrank</label>
                                    <div class="slider-container">
                                        <input type="range" id="dayConsumption" min="0" max="3" value="0.8" step="0.1">
                                        <span class="slider-value" id="dayValue">0.8 kW</span>
                                    </div>
                                </div>
                                
                                <div class="control-group">
                                    <label>üåÜ Abends (17:00-22:00) - Kochen, TV, Beleuchtung</label>
                                    <div class="slider-container">
                                        <input type="range" id="eveningConsumption" min="0" max="8" value="3.5" step="0.5">
                                        <span class="slider-value" id="eveningValue">3.5 kW</span>
                                    </div>
                                </div>
                                
                                <div class="control-group">
                                    <label>üåÉ Nachts (22:00-06:00) - Standby, K√ºhlschrank</label>
                                    <div class="slider-container">
                                        <input type="range" id="nightConsumption" min="0" max="2" value="0.5" step="0.1">
                                        <span class="slider-value" id="nightValue">0.5 kW</span>
                                    </div>
                                </div>
                                
                                <button onclick="updateConsumptionAndCalculate()" style="width: 100%; margin-top: 15px;">
                                    üîÑ Verbrauch aktualisiere & neu berechnen
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="tab-comparison" class="tab-content" style="display: none;">
                        <h3>üìà Preis vs. Verbrauch im Vergleich</h3>
                        <div class="chart-container">
                            <canvas id="comparisonChart"></canvas>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div>G√ºnstigste Verbrauchszeit</div>
                                <div id="bestConsumptionTime" class="stat-value">-</div>
                                <div id="bestConsumptionPrice">- ct/kWh</div>
                            </div>
                            <div class="stat-item">
                                <div>Teuerste Verbrauchszeit</div>
                                <div id="worstConsumptionTime" class="stat-value">-</div>
                                <div id="worstConsumptionPrice">- ct/kWh</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <h4>üí∞ Aktuelle Kosten√ºbersicht:</h4>
                            <div class="result-item">
                                <span class="result-label">T√§glicher Gesamtverbrauch:</span>
                                <span class="result-value" id="totalDailyConsumption">- kWh</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">Durchschnittspreis:</span>
                                <span class="result-value" id="currentAvgPrice">- ct/kWh</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">Aktuelle Tageskosten:</span>
                                <span class="result-value" id="currentDailyCost">- ‚Ç¨</span>
                            </div>
                        </div>
                    </div>
                    
                    <div id="tab-savings" class="tab-content" style="display: none;">
                        <h3>üí∞ Ersparnis-Potential</h3>
                        
                        <div class="optimization-results">
                            <h4>üìä Kostenvergleich</h4>
                            <div class="result-item">
                                <span class="result-label">Aktuelle t√§gliche Kosten:</span>
                                <span class="result-value" id="currentCostDisplay">- ‚Ç¨</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">Optimierte t√§gliche Kosten:</span>
                                <span class="result-value" id="optimizedCostDisplay">- ‚Ç¨</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">T√§gliche Ersparnis:</span>
                                <span class="result-value" id="dailySavingsDisplay">- ‚Ç¨</span>
                            </div>
                            
                            <div class="progress-bar">
                                <div id="savingsProgress" class="progress-fill" style="width: 0%;"></div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 10px;">
                                <span id="savingsPercent">0%</span> Einsparung m√∂glich
                            </div>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div>Monatliche Ersparnis</div>
                                <div id="monthlySavings" class="stat-value">- ‚Ç¨</div>
                                <div>bei Umstellung</div>
                            </div>
                            <div class="stat-item">
                                <div>J√§hrliche Ersparnis</div>
                                <div id="yearlySavings" class="stat-value">- ‚Ç¨</div>
                                <div>bei Umstellung</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 25px;">
                            <h4>üí° Einspar-Tipps:</h4>
                            <div id="savingTips"></div>
                        </div>
                    </div>
                    
                    <div id="tab-optimization" class="tab-content" style="display: none;">
                        <h3>‚ö° Optimierungs-Ergebnisse</h3>
                        
                        <div class="optimization-results">
                            <h4>‚úÖ Empfohlene Ma√ünahmen:</h4>
                            <div id="optimizationActions"></div>
                            
                            <h4 style="margin-top: 25px;">üìÖ Optimierter Tagesplan:</h4>
                            <div id="optimizedSchedule"></div>
                            
                            <h4 style="margin-top: 25px;">üîã Akku-Strategie:</h4>
                            <div id="batteryStrategy"></div>
                        </div>
                    </div>

                    <!-- NEUER Tab f√ºr KI-Prognose -->
                    <div id="tab-forecast" class="tab-content" style="display: none;">
                        <h3>ü§ñ KI-basierte 3-Tage Strompreis-Prognose</h3>
                        
                        <div class="info" style="margin-bottom: 20px;">
                            <strong>üß† Machine Learning Modell:</strong> Analysiert historische EPEX-Daten und Wettervorhersagen f√ºr pr√§zise Prognosen
                        </div>
                        
                        <div class="btn-group">
                            <button onclick="loadWeatherData()" class="btn-small">üå§Ô∏è Wetter laden</button>
                            <button onclick="trainPredictionModel()" class="btn-small">ü§ñ KI-Modell trainieren</button>
                            <button onclick="generate3DayForecast()" class="btn-small">üìä 3-Tage Prognose</button>
                            <button onclick="analyzeForecastAccuracy()" class="btn-small">üéØ Genauigkeit pr√ºfen</button>
                        </div>
                        
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="forecastChart"></canvas>
                        </div>
                        
                        <div class="stats-grid" style="margin-top: 20px;">
                            <div class="stat-item">
                                <div>KI Modell Status</div>
                                <div id="modelStatus" class="stat-value">Nicht trainiert</div>
                                <div id="modelAccuracy">-</div>
                            </div>
                            <div class="stat-item">
                                <div>Wetterdaten</div>
                                <div id="weatherStatus" class="stat-value">Nicht geladen</div>
                                <div id="weatherLocation">-</div>
                            </div>
                            <div class="stat-item">
                                <div>Prognose-Genauigkeit</div>
                                <div id="forecastAccuracy" class="stat-value">- %</div>
                                <div>Letzte Pr√ºfung</div>
                            </div>
                            <div class="stat-item">
                                <div>Empf. Kaufzeit</div>
                                <div id="bestBuyTime" class="stat-value">-</div>
                                <div id="bestBuyPrice">- ct/kWh</div>
                            </div>
                        </div>
                        
                        <div class="optimization-results" style="margin-top: 20px;">
                            <h4>üìÖ 3-Tage Prognose-Details:</h4>
                            <div id="forecastDetails"></div>
                            
                            <h4 style="margin-top: 20px;">üå§Ô∏è Aktuelle Wetterdaten:</h4>
                            <div id="currentWeather"></div>
                            
                            <h4 style="margin-top: 20px;">üßÆ KI-Modell Details:</h4>
                            <div id="modelDetails"></div>
                        </div>
                    </div>

                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div>Tagesdurchschnitt</div>
                        <div id="avgPrice" class="stat-value">- ct/kWh</div>
                        <div>‚Ç¨/MWh: <span id="avgPriceMWh">-</span></div>
                    </div>
                    <div class="stat-item">
                        <div>G√ºnstigste Stunde</div>
                        <div id="bestTime" class="stat-value">-</div>
                        <div><span id="bestPrice">-</span> ct/kWh</div>
                    </div>
                    <div class="stat-item">
                        <div>Teuerste Stunde</div>
                        <div id="worstTime" class="stat-value">-</div>
                        <div><span id="worstPrice">-</span> ct/kWh</div>
                    </div>
                    <div class="stat-item">
                        <div>Empf. Ladezeit</div>
                        <div id="chargeTime" class="stat-value">-</div>
                        <div><span id="chargeHours">-</span> Stunden</div>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button onclick="calculateOptimization()" style="background: #0984e3; padding: 18px 40px; font-size: 18px;">
                        üîÑ OPTIMIERUNG JETZT BERECHNEN
                    </button>
                    <div style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                        Klicken Sie hier um alle Berechnungen durchzuf√ºhren
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <h3>‚öôÔ∏è Einstellungen</h3>
                
                <div class="control-group">
                    <label>üîã Akku-Ladezustand (%)</label>
                    <div class="slider-container">
                        <input type="range" id="batteryLevel" min="0" max="100" value="35" step="5">
                        <span class="slider-value" id="batteryValue">35%</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üîã Akku-Kapazit√§t</label>
                    <select id="batteryCapacity">
                        <option value="5">5 kWh (kleiner Hausakku)</option>
                        <option value="10" selected>10 kWh (typischer Hausakku)</option>
                        <option value="15">15 kWh (gro√üer Hausakku)</option>
                        <option value="50">50 kWh (E-Auto)</option>
                        <option value="75">75 kWh (gro√ües E-Auto)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>‚ö° Ladeleistung</label>
                    <select id="chargePower">
                        <option value="2.3">2.3 kW (Haushaltssteckdose)</option>
                        <option value="3.7">3.7 kW (Wallbox Basic)</option>
                        <option value="11" selected>11 kW (Wallbox Standard)</option>
                        <option value="22">22 kW (Wallbox Pro)</option>
                    </select>
                </div>
                
                <div class="battery-section">
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div>üîã Akku-Ladestatus</div>
                        <div style="font-size: 1.5rem; font-weight: bold;" id="batteryPercent">35%</div>
                    </div>
                    <div class="battery-level">
                        <div id="batteryFill" class="battery-fill" style="width: 35%;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <button onclick="chargeBattery(10)" class="btn-small" style="padding: 8px 12px; font-size: 0.85rem; background: #00b894; color: white; border: none; border-radius: 6px; cursor: pointer;">+10%</button>
                        <button onclick="chargeBattery(25)" class="btn-small" style="padding: 8px 12px; font-size: 0.85rem; background: #00b894; color: white; border: none; border-radius: 6px; cursor: pointer;">+25%</button>
                        <button onclick="dischargeBattery(10)" class="btn-small" style="padding: 8px 12px; font-size: 0.85rem; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer;">-10%</button>
                        <button onclick="dischargeBattery(25)" class="btn-small" style="padding: 8px 12px; font-size: 0.85rem; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer;">-25%</button>
                    </div>
                    <div style="text-align: center; margin-top: 15px;">
                        <button onclick="setBatteryLevel()" style="width: 100%; padding: 10px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">
                            üî¢ Manuell eingeben
                        </button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üå°Ô∏è W√§rmepumpe (2.5 kW)</label>
                    <select id="heatpumpMode">
                        <option value="none">Keine</option>
                        <option value="auto" selected>Automatisch (bei g√ºnstigen Preisen)</option>
                        <option value="eco">Eco (nur g√ºnstigste Zeiten)</option>
                        <option value="continuous">Dauerbetrieb</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>üß∫ Waschmaschine (2.0 kW)</label>
                    <select id="laundryTime">
                        <option value="auto">Automatisch (g√ºnstigste Zeit)</option>
                        <option value="morning" selected>Morgens</option>
                        <option value="afternoon">Nachmittags</option>
                        <option value="night">Nachts</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>üå§Ô∏è Aktuelles Wetter & Prognose</label>
                    <div id="weatherDisplay" style="padding: 12px; background: #e3f2fd; border-radius: 8px; margin-top: 8px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span id="weatherIcon">‚è≥</span>
                            <div>
                                <div id="weatherText">Lade Wetterdaten...</div>
                                <div id="weatherDetails" style="font-size: 0.85rem; color: #666;">
                                    Klicken Sie auf "Wetter aktualisieren"
                                </div>
                            </div>
                        </div>
                        <button onclick="loadAndApplyRealWeather()" 
                                style="width: 100%; margin-top: 10px; padding: 8px; background: #2196f3;">
                            üå§Ô∏è Wetter aktualisieren
                        </button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>üìÖ Wochentag</label>
                    <select id="weekday">
                        <option value="1">Montag (Werktag)</option>
                        <option value="2">Dienstag (Werktag)</option>
                        <option value="3">Mittwoch (Werktag)</option>
                        <option value="4">Donnerstag (Werktag)</option>
                        <option value="5">Freitag (Werktag)</option>
                        <option value="6">Samstag (Wochenende)</option>
                        <option value="0">Sonntag (Wochenende)</option>
                    </select>
                </div>
                
                <button onclick="calculateOptimization()" style="width: 100%; background: #0984e3; margin-top: 20px; padding: 14px;">
                    üßÆ Optimierung berechnen
                </button>
                
                <div class="recommendation-card">
                    <h4>üí° Empfehlung</h4>
                    <div id="recommendationText">Berechnung wurde noch nicht durchgef√ºhrt</div>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        <div>üìä Letzte Berechnung: <span id="lastCalculation">Nie</span></div>
                        <div>üí∞ Ersparnis m√∂glich: <span id="potentialSavings">-</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            <div>üì° Berechne Optimierung...</div>
            <div style="margin-top: 10px; font-size: 0.9rem; color: #888;">
                Analysiere <span id="calcStep">Preise und Verbrauch</span>...
            </div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        <div id="success" class="success" style="display: none;"></div>

        <footer class="app-footer" style="padding: 15px; text-align: center; font-size: 0.85em;">
            <p class="footer-text">
                <span style="vertical-align: middle;">
                    Intelligente Strompreis-Optimierung | 
                    Copyright ¬© <script>document.write(new Date().getFullYear())</script> 
                    Friedhelm Koch | Lizenz: 
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.de" 
                    target="_blank" style="color: rgb(2, 103, 204);">CC BY-NC-ND 4.0</a><br />
                </span>
            </p>
            <p>Unter Verwendung von smartENERGY API, TensorFlow und Nominatim<br /></p>
        </footer>


        <!-- Training-Status Modal -->
        <div id="trainingModal" class="training-modal">
            <button class="training-close-btn" onclick="hideTrainingModal()">√ó</button>
            
            <div class="training-content">
                <div class="training-header">
                    <div class="training-spinner">ü§ñ</div>
                    <h3>KI-Modell Training</h3>
                </div>
                
                <div class="training-status-text" id="trainingStatus">
                    Initialisierung...
                </div>
                
                <div class="training-detail-text" id="trainingDetail">
                    Bereite Training vor...
                </div>
                
                <div class="training-progress-container">
                    <div id="trainingProgressBar" class="training-progress-bar"></div>
                </div>
                
                <div class="training-stats">
                    <div class="training-stat">
                        <div class="training-stat-label">Epoche</div>
                        <div id="currentEpoch" class="training-stat-value">0/50</div>
                    </div>
                    <div class="training-stat">
                        <div class="training-stat-label">Loss</div>
                        <div id="currentLoss" class="training-stat-value">-</div>
                    </div>
                    <div class="training-stat">
                        <div class="training-stat-label">Verbleibend</div>
                        <div id="timeRemaining" class="training-stat-value">-</div>
                    </div>
                    <div class="training-stat">
                        <div class="training-stat-label">Status</div>
                        <div id="trainingSpeed" class="training-stat-value">-</div>
                    </div>
                </div>
                
                <!-- Einfache Mini-Chart Visualisierung f√ºr Mobile -->
                <div class="training-mini-chart" id="trainingMiniChart">
                    <!-- Wird dynamisch mit JavaScript gef√ºllt -->
                </div>
                
                <!-- Vereinfachte Logs f√ºr Mobile -->
                <div class="training-logs-container" id="trainingLogs">
                    <div class="training-log-entry">Training wird gestartet...</div>
                </div>
                
                <!-- Adaptive Buttons -->
                <div class="training-buttons">
                    <button class="training-button training-button-cancel" onclick="stopTraining()">
                        ‚ùå Training abbrechen
                    </button>
                    <button class="training-button training-button-background" onclick="hideTrainingModal()">
                        ‚è∏Ô∏è Im Hintergrund
                    </button>
                    <button class="training-button training-button-close" onclick="hideTrainingModal()" style="display: none;" id="closeTrainingBtn">
                        ‚úÖ Schlie√üen
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Chart.js f√ºr Diagramme -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- TensorFlow.js f√ºr KI-Prognosen -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

    <script>
        // Globale Variablen
        let priceChart = null;
        let consumptionChart = null;
        let comparisonChart = null;
        let currentPrices = [];
        let consumptionProfile = [];
        let batteryLevel = 35;
        let lastCalculationTime = null;

        // Globale Variablen f√ºr KI und Wetter
        let forecastChart = null;
        let predictionModel = null;
        let weatherData = null;
        let isModelTrained = false;
        let forecastData = [];

        // Open-Meteo API Konfiguration
        const WEATHER_API = {
            baseUrl: 'https://api.open-meteo.com/v1/forecast',
            defaultParams: {
                latitude: 48.2082,  // Wien
                longitude: 16.3738,
                hourly: 'temperature_2m,cloud_cover,wind_speed_10m,precipitation_probability',
                timezone: 'Europe/Berlin',
                forecast_days: 3
            }
        };
        
        // Standard-Verbrauchsprofil (in kW)
        const DEFAULT_CONSUMPTION = {
            morning: 2.0,
            day: 0.8,
            evening: 3.5,
            night: 0.5
        };

        // Preismuster f√ºr Wochentage und Wochenende
        const PRICE_PATTERNS = {
            weekday: {
                "00-06": { base: 18, description: "Nachttarif" },
                "06-09": { base: 28, description: "Morgenpeak" },
                "09-17": { base: 35, description: "Standard" },
                "17-21": { base: 42, description: "Abendpeak" },
                "21-24": { base: 30, description: "Standard" }
            },
            weekend: {
                "00-09": { base: 15, description: "Nachttarif" },
                "09-12": { base: 25, description: "Standard" },
                "12-18": { base: 32, description: "Standard" },
                "18-22": { base: 38, description: "Abend" },
                "22-24": { base: 20, description: "Nachttarif" }
            }
        };

        // Wettereinfluss auf Preise
        const WEATHER_IMPACT = {
            sunny: { factor: 0.85, description: "Viel Sonne - viel Solar" },
            partly_cloudy: { factor: 0.95, description: "Leicht bew√∂lkt - m√§√üig Solar" },
            cloudy: { factor: 1.05, description: "Bew√∂lkt - wenig Solar" },
            rainy: { factor: 1.10, description: "Regen - hoher Verbrauch" },
            windy: { factor: 0.90, description: "Windig - viel Windkraft" },
            stormy: { factor: 1.15, description: "Sturm - Einschr√§nkungen" },
            snow: { factor: 1.20, description: "Schnee - hohe Heizlast" }
        };

        // Wetter-Daten-Struktur
        let currentWeather = {
            temperature: null,
            cloudCover: null,
            windSpeed: null,
            rainProbability: null,
            condition: null,
            icon: '‚è≥',
            lastUpdate: null,
            location: 'Wien, AT',
            isRealData: false
        };

        // Wetterbedingungen zu unseren Kategorien mappen
        const WEATHER_CONDITIONS = {
            // Klarer Himmel
            'clear': 'klarer Himmel',
            'sunny': 'sonnig',
            
            // Teilweise bew√∂lkt
            'partly cloudy': 'teilweise bew√∂lkt',
            'partly_cloudy': 'teilweise bew√∂lkt',
            
            // Bew√∂lkt
            'cloudy': 'bew√∂lkt',
            'overcast': 'stark bew√∂lkt',
            
            // Regen
            'rain': 'Regen',
            'light rain': 'leichter Regen',
            'moderate rain': 'm√§√üiger Regen',
            'heavy rain': 'starker Regen',
            'drizzle': 'Nieselregen',
            'freezing drizzle': 'gefrierender Nieselregen',
            
            // Schnee
            'snow': 'Schneefall',
            'light snow': 'leichter Schnee',
            'heavy snow': 'starker Schnee',
            'snow grains': 'Schneegraupel',
            'sleet': 'Schneeregen',
            
            // Wind
            'windy': 'windig',
            
            // Sturm
            'thunderstorm': 'Gewitter',
            'storm': 'Sturm',
            'heavy thunderstorm': 'starkes Gewitter',
            
            // Nebel
            'fog': 'Nebel',
            
            // Sonstige
            'rain showers': 'Regenschauer',
            'heavy rain showers': 'starke Regenschauer',
            'snow showers': 'Schneeschauer',
            'heavy snow showers': 'starke Schneeschauer',
            'freezing rain': 'gefrierender Regen'
        };

        // Deutsche Wetter-Icons (optional passendere Icons)
        const GERMAN_WEATHER_ICONS = {
            'sonnig': '‚òÄÔ∏è',
            'teilweise bew√∂lkt': '‚õÖ',
            'bew√∂lkt': '‚òÅÔ∏è',
            'stark bew√∂lkt': '‚òÅÔ∏è',
            'Regen': 'üåßÔ∏è',
            'leichter Regen': 'üå¶Ô∏è',
            'm√§√üiger Regen': 'üåßÔ∏è',
            'starker Regen': 'üåßÔ∏è',
            'Nieselregen': 'üå¶Ô∏è',
            'gefrierender Nieselregen': 'üåßÔ∏è‚ùÑÔ∏è',
            'Schnee': '‚ùÑÔ∏è',
            'leichter Schnee': 'üå®Ô∏è',
            'starker Schnee': '‚ùÑÔ∏èüå®Ô∏è',
            'Schneegriesel': 'üå®Ô∏è',
            'Schneeregen': 'üåßÔ∏è‚ùÑÔ∏è',
            'windig': 'üí®',
            'Gewitter': '‚õàÔ∏è',
            'Sturm': 'üå™Ô∏è',
            'starkes Gewitter': '‚õàÔ∏è‚ö°',
            'Nebel': 'üå´Ô∏è',
            'Regenschauer': 'üåßÔ∏è',
            'starke Regenschauer': 'üåßÔ∏èüí¶',
            'Schneeschauer': 'üå®Ô∏è',
            'starke Schneeschauer': '‚ùÑÔ∏èüå®Ô∏è',
            'gefrierender Regen': 'üåßÔ∏è‚ùÑÔ∏è',
            'unknown': 'üåà'
        };

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            setupSliders();
            updateBatteryDisplay();
            generateConsumptionProfile();
            loadData('today');
            
            // Event-Listener
            document.getElementById('weekday').addEventListener('change', () => {
                loadData('today');
                calculateOptimization();
            });
            document.getElementById('heatpumpMode').addEventListener('change', () => calculateOptimization());
            document.getElementById('laundryTime').addEventListener('change', () => calculateOptimization());
            document.getElementById('batteryCapacity').addEventListener('change', () => calculateOptimization());
            document.getElementById('chargePower').addEventListener('change', () => calculateOptimization());
            
            // Automatisch Wetter laden
            setTimeout(() => {
                loadAndApplyRealWeather();
            }, 2000);
            
            // Starte automatische Wetteraktualisierung
            startWeatherAutoRefresh();
            
            // AUTOMATISCHE KI-INITIALISIERUNG - NEU
            setTimeout(() => {
                initializeKIPrognose();
            }, 3000);
        });

        // NEUE Funktion: KI-Prognose automatisch initialisieren
        async function initializeKIPrognose() {
            try {
                // 1. Wetterdaten laden (falls noch nicht geschehen)
                if (!weatherData) {
                    await loadWeatherData();
                }
                
                // 2. KI-Modell vorbereiten (aber nicht sofort trainieren)
                if (!predictionModel) {
                    await createPredictionModel();
                }
                
                // 3. Standard-Prognose mit simulierten Daten anzeigen
                generateDefaultForecast();
                
            } catch (error) {
                console.log('KI-Initialisierung fehlgeschlagen:', error);
                // Fallback: Standardmeldung anzeigen
                document.getElementById('forecastDetails').innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666;">
                        <div>ü§ñ KI-Prognose wird initialisiert...</div>
                        <button onclick="initializeKIPrognose()" style="margin-top: 10px; padding: 8px 15px;">
                            üîÑ Erneut versuchen
                        </button>
                    </div>
                `;
            }
        }

        // NEUE Funktion: Standard-Prognose mit simulierten Daten
        function generateDefaultForecast() {
            const now = new Date();
            forecastData = [];
            
            // Simulierte Prognose f√ºr 3 Tage
            for (let dayOffset = 0; dayOffset < 3; dayOffset++) {
                for (let hour = 0; hour < 24; hour++) {
                    const targetDate = new Date(now);
                    targetDate.setDate(targetDate.getDate() + dayOffset);
                    targetDate.setHours(hour, 0, 0, 0);
                    
                    // Simulierte Preise basierend auf typischen Mustern
                    let basePrice;
                    if (hour >= 0 && hour < 6) basePrice = 18 + Math.random() * 5;
                    else if (hour >= 6 && hour < 9) basePrice = 28 + Math.random() * 8;
                    else if (hour >= 9 && hour < 17) basePrice = 35 + Math.random() * 10;
                    else if (hour >= 17 && hour < 21) basePrice = 42 + Math.random() * 12;
                    else basePrice = 30 + Math.random() * 8;
                    
                    // Wochenende-Anpassung
                    const weekday = targetDate.getDay();
                    if (weekday === 0 || weekday === 6) {
                        basePrice *= 0.8;
                    }
                    
                    forecastData.push({
                        dayOffset: dayOffset,
                        hour: hour,
                        date: targetDate,
                        predictedPrice: basePrice,
                        temperature: 15 + Math.random() * 10,
                        cloudCover: Math.random() * 100,
                        windSpeed: 5 + Math.random() * 20,
                        rainProb: Math.random() * 50,
                        weekday: weekday,
                        isSimulated: true
                    });
                }
            }
            
            // Prognose anzeigen
            displayForecast();
            updateForecastChart();
            findBestBuyTime();
            
            // Status aktualisieren
            document.getElementById('modelStatus').textContent = 'Bereit';
            document.getElementById('modelAccuracy').textContent = 'Simulierte Daten';
            document.getElementById('weatherStatus').textContent = weatherData ? 'Geladen' : 'Simuliert';
            document.getElementById('weatherLocation').textContent = currentWeather.location || 'Simuliert';
            document.getElementById('forecastAccuracy').textContent = '- %';
            
            showMessage('üìä Standard-Prognose geladen');
        }

        // ========================================
        // GEOLOCATION & WETTER ERWEITERUNGEN
        // ========================================

        // Geolocation abfragen mit Fallback zu Nominatim
        async function getLocation() {
            return new Promise((resolve, reject) => {
                // Erst versuchen wir die Browser-Geolocation
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            console.log("Geolocation erfolgreich:", position.coords);
                            
                            // Try to get location name via reverse geocoding
                            const locationName = await reverseGeocode(
                                position.coords.latitude, 
                                position.coords.longitude
                            );
                            
                            resolve({
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                name: locationName || `Position (${position.coords.latitude.toFixed(4)}, ${position.coords.longitude.toFixed(4)})`,
                                source: 'browser'
                            });
                        },
                        async (error) => {
                            console.warn("Geolocation fehlgeschlagen:", error.message);
                            
                            // Fallback: IP-basierte Standortbestimmung
                            try {
                                const ipLocation = await getLocationByIP();
                                if (ipLocation) {
                                    resolve(ipLocation);
                                } else {
                                    // Finaler Fallback: Standard-Standort
                                    resolve(getDefaultLocation());
                                }
                            } catch (ipError) {
                                console.error("IP-Location fehlgeschlagen:", ipError);
                                resolve(getDefaultLocation());
                            }
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 600000 // 10 Minuten
                        }
                    );
                } else {
                    // Browser unterst√ºtzt keine Geolocation
                    console.log("Browser unterst√ºtzt keine Geolocation");
                    getLocationByIP()
                        .then(resolve)
                        .catch(() => resolve(getDefaultLocation()));
                }
            });
        }

        // Reverse Geocoding mit Nominatim
        async function reverseGeocode(lat, lon) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=de`;
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'Strompreis-Optimierung/1.0'
                    }
                });
                
                if (!response.ok) throw new Error('Nominatim API Error');
                
                const data = await response.json();
                
                if (data.address) {
                    // Extrahiere den Ortsnamen
                    let locationName = '';
                    if (data.address.city) {
                        locationName = data.address.city;
                    } else if (data.address.town) {
                        locationName = data.address.town;
                    } else if (data.address.village) {
                        locationName = data.address.village;
                    } else if (data.address.municipality) {
                        locationName = data.address.municipality;
                    }
                    
                    if (data.address.state || data.address.country) {
                        locationName += locationName ? ', ' : '';
                        locationName += data.address.state || data.address.country;
                    }
                    
                    return locationName || `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
                }
            } catch (error) {
                console.warn("Reverse Geocoding fehlgeschlagen:", error);
            }
            return null;
        }

        // IP-basierte Standortbestimmung
        async function getLocationByIP() {
            try {
                const response = await fetch('https://ipapi.co/json/');
                if (!response.ok) throw new Error('IP API Error');
                
                const data = await response.json();
                
                return {
                    latitude: data.latitude,
                    longitude: data.longitude,
                    accuracy: 50000, // IP ist ungenau
                    name: data.city ? `${data.city}, ${data.country_name}` : data.country_name,
                    source: 'ip'
                };
            } catch (error) {
                console.warn("IP-basierte Standortbestimmung fehlgeschlagen:", error);
                return null;
            }
        }

        // Standard-Standort (Wien)
        function getDefaultLocation() {
            return {
                latitude: 48.2082,
                longitude: 16.3738,
                accuracy: 10000,
                name: 'Wien, √ñsterreich',
                source: 'default'
            };
        }

        // Dynamischer Wetter-Einfluss basierend auf echten Daten
        function calculateWeatherImpact(weatherData) {
            if (!weatherData || !weatherData.isRealData) {
                // Fallback zu statischem Wert
                return WEATHER_IMPACT.sunny;
            }
            
            const { temperature, cloudCover, windSpeed, rainProbability, condition } = weatherData;
            
            // KI-basierte Berechnung des Wettereinflusses
            let factor = 1.0;
            let description = "Normal";
            
            // Solar-Einfluss (Bew√∂lkung)
            if (cloudCover < 20) {
                factor *= 0.85; // Viel Sonne = viel Solar
                description = "Viel Solarstrom";
            } else if (cloudCover < 50) {
                factor *= 0.95; // Leicht bew√∂lkt = m√§√üig Solar
                description = "M√§√üig Solarstrom";
            } else if (cloudCover < 80) {
                factor *= 1.05; // Stark bew√∂lkt = wenig Solar
                description = "Wenig Solarstrom";
            } else {
                factor *= 1.10; // Bedeckt = sehr wenig Solar
                description = "Sehr wenig Solarstrom";
            }
            
            // Wind-Einfluss
            if (windSpeed > 30) {
                factor *= 0.80; // Sehr windig = viel Windstrom
                description += ", viel Windstrom";
            } else if (windSpeed > 15) {
                factor *= 0.90; // Windig = m√§√üig Windstrom
                description += ", m√§√üig Windstrom";
            }
            
            // Temperatur-Einfluss (Heizung/K√ºhlung)
            if (temperature < 0) {
                factor *= 1.20; // Sehr kalt = mehr Heizung
                description += ", hohe Heizlast";
            } else if (temperature < 10) {
                factor *= 1.10; // Kalt = mehr Heizung
                description += ", erh√∂hte Heizlast";
            } else if (temperature > 28) {
                factor *= 1.15; // Sehr hei√ü = mehr K√ºhlung
                description += ", hohe K√ºhllast";
            } else if (temperature > 22) {
                factor *= 1.05; // Warm = etwas mehr K√ºhlung
                description += ", erh√∂hte K√ºhllast";
            }
            
            // Regen-Einfluss (mehr Innenaktivit√§ten)
            if (rainProbability > 70) {
                factor *= 1.10; // Viel Regen = mehr Innenverbrauch
                description += ", hoher Innenverbrauch";
            } else if (rainProbability > 30) {
                factor *= 1.05; // Etwas Regen = erh√∂hter Innenverbrauch
                description += ", erh√∂hter Innenverbrauch";
            }
            
            // Runden
            factor = Math.round(factor * 100) / 100;
            
            return {
                factor: factor,
                description: description,
                condition: condition,
                temperature: temperature,
                cloudCover: cloudCover
            };
        }

        // Echte Wetterdaten laden und anwenden MIT GEOLOCATION
        async function loadAndApplyRealWeather() {
            showLoading(true);
            document.getElementById('calcStep').textContent = 'Ermittle Standort...';
            
            try {
                // 1. Standort bestimmen
                const location = await getLocation();
                console.log("Verwende Standort:", location);
                
                // 2. Wetter f√ºr diesen Standort laden
                document.getElementById('calcStep').textContent = 'Lade Live-Wetterdaten...';
                const weather = await fetchRealWeatherData(location);
                
                // 3. In globaler Variable speichern
                currentWeather = weather;
                currentWeather.lastUpdate = new Date();
                currentWeather.isRealData = true;
                
                // 4. Wetter anzeigen
                updateWeatherDisplay();
                
                // 5. Wetter-Einfluss berechnen
                const weatherImpact = calculateWeatherImpact(weather);
                
                // 6. Alle Berechnungen mit neuem Wetter aktualisieren
                recalculateWithWeather(weatherImpact);
                
                showMessage(`‚úÖ Wetterdaten f√ºr ${location.name} aktualisiert: ${weather.temperature}¬∞C, ${weather.condition}`);
                
            } catch (error) {
                console.error('Wetter-Fehler:', error);
                showError('Wetterdaten konnten nicht geladen werden');
            } finally {
                showLoading(false);
            }
        }

        // Echte Wetterdaten von Open-Meteo laden F√úR SPEZIFISCHEN STANDORT
        async function fetchRealWeatherData(location) {
            const params = {
                latitude: location.latitude,
                longitude: location.longitude,
                current: 'temperature_2m,cloud_cover,wind_speed_10m,precipitation_probability,weather_code',
                hourly: 'temperature_2m,cloud_cover,wind_speed_10m,precipitation_probability,weather_code',
                timezone: 'Europe/Berlin',
                forecast_days: 1
            };
            
            const queryString = new URLSearchParams(params).toString();
            const url = `https://api.open-meteo.com/v1/forecast?${queryString}`;
            
            console.log('Lade Wetter von:', url);
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Wetter-API: ${response.status}`);
            
            const data = await response.json();
            
            // Wettercode zu lesbarem Text konvertieren
            const weatherCode = data.current.weather_code;
            const condition = interpretWeatherCode(weatherCode);
            
            // Speichere auch die st√ºndlichen Daten f√ºr die KI-Prognose
            if (data.hourly) {
                weatherData = data;
            }
            
            return {
                temperature: data.current.temperature_2m,
                cloudCover: data.current.cloud_cover,
                windSpeed: data.current.wind_speed_10m,
                rainProbability: data.current.precipitation_probability,
                condition: condition,
                icon: getWeatherIcon(condition),
                location: location.name,
                rawData: data
            };
        }

        // WMO Weather Interpretation Codes (Open-Meteo verwendet WMO)
        function interpretWeatherCode(code) {
            // Deutsche Wetterinterpretation f√ºr WMO Codes
            const codes = {
                0: 'sonnig',
                1: 'teilweise bew√∂lkt',
                2: 'teilweise bew√∂lkt',
                3: 'bew√∂lkt',
                45: 'Nebel',
                48: 'Nebel',
                51: 'leichter Nieselregen',
                53: 'm√§√üiger Nieselregen',
                55: 'starker Nieselregen',
                56: 'gefrierender leichter Nieselregen',
                57: 'gefrierender starker Nieselregen',
                61: 'leichter Regen',
                63: 'm√§√üiger Regen',
                65: 'starker Regen',
                66: 'leichter gefrierender Regen',
                67: 'starker gefrierender Regen',
                71: 'leichter Schneefall',
                73: 'm√§√üiger Schneefall',
                75: 'starker Schneefall',
                77: 'Schneegriesel',
                80: 'leichte Regenschauer',
                81: 'm√§√üige Regenschauer',
                82: 'starke Regenschauer',
                85: 'leichte Schneeschauer',
                86: 'starke Schneeschauer',
                95: 'leichtes Gewitter',
                96: 'leichtes Gewitter mit Hagel',
                99: 'starkes Gewitter mit Hagel'
            };
            
            return codes[code] || 'unbekannt';
        }

        function getWeatherIcon(condition, detailed = false) {
            // Falls condition noch englisch ist, √ºbersetze es
            const germanCondition = WEATHER_CONDITIONS[condition] || condition;
            
            // Basis-Icons
            const baseIcons = {
                'sonnig': '‚òÄÔ∏è',
                'klar': '‚òÄÔ∏è',
                'klarer himmel': '‚òÄÔ∏è',
                '√ºberwiegend sonnig': 'üå§Ô∏è',
                'teilweise bew√∂lkt': '‚õÖ',
                'bew√∂lkt': '‚òÅÔ∏è',
                'bedeckt': '‚òÅÔ∏è',
                'stark bew√∂lkt': '‚òÅÔ∏è',
                'nebel': 'üå´Ô∏è',
                'nebelig': 'üå´Ô∏è',
                'nebelig mit reif': 'üå´Ô∏è‚ùÑÔ∏è',
                'regenschauer': 'üåßÔ∏è',
                'leichte regenschauer': 'üå¶Ô∏è',
                'm√§√üige regenschauer': 'üåßÔ∏è',
                'starke regenschauer': 'üåßÔ∏èüí¶',
                'nieselregen': 'üå¶Ô∏è',
                'leichter nieselregen': 'üå¶Ô∏è',
                'm√§√üiger nieselregen': 'üåßÔ∏è',
                'starker nieselregen': 'üåßÔ∏è',
                'gefrierender nieselregen': 'üåßÔ∏è‚ùÑÔ∏è',
                'regen': 'üåßÔ∏è',
                'leichter regen': 'üå¶Ô∏è',
                'm√§√üiger regen': 'üåßÔ∏è',
                'starker regen': 'üåßÔ∏è',
                'gefrierender regen': 'üåßÔ∏è‚ùÑÔ∏è',
                'schneefall': '‚ùÑÔ∏è',
                'leichter schneefall': 'üå®Ô∏è',
                'm√§√üiger schneefall': '‚ùÑÔ∏è',
                'starker schneefall': '‚ùÑÔ∏èüå®Ô∏è',
                'schneegriesel': 'üå®Ô∏è',
                'schneeschauer': 'üå®Ô∏è',
                'leichte schneeschauer': 'üå®Ô∏è',
                'starke schneeschauer': '‚ùÑÔ∏èüå®Ô∏è',
                'schneeregen': 'üåßÔ∏è‚ùÑÔ∏è',
                'gewitter': '‚õàÔ∏è',
                'leichtes gewitter': '‚õàÔ∏è',
                'starkes gewitter': '‚õàÔ∏è‚ö°',
                'gewitter mit hagel': '‚õàÔ∏èüßä',
                'windig': 'üí®',
                'st√ºrmisch': 'üå™Ô∏è',
                'unbekannt': 'üåà'
            };
            
            // F√ºr detaillierte Ansicht evtl. andere Icons
            if (detailed) {
                const detailedIcons = {
                    'klar': 'üåû',
                    'teilweise bew√∂lkt': 'üå•Ô∏è',
                    'bedeckt': '‚òÅÔ∏è',
                    'nebel': 'üò∂‚Äçüå´Ô∏è',
                    'regen': '‚òî',
                    'schnee': '‚õÑ',
                    'gewitter': '‚ö°',
                    'wind': 'üçÉ'
                };
                
                return detailedIcons[germanCondition.toLowerCase()] || baseIcons[germanCondition.toLowerCase()] || 'üåà';
            }
            
            return baseIcons[germanCondition.toLowerCase()] || 'üåà';
        }

        // Alternative: Detailliertere deutsche Beschreibungen
        function interpretWeatherCodeDetailed(code) {
            const detailedCodes = {
                0: 'Klarer Himmel',
                1: '√úberwiegend sonnig',
                2: 'Teilweise bew√∂lkt',
                3: 'Bedeckt',
                45: 'Neblig',
                48: 'Neblig mit Reif',
                51: 'Leichter Nieselregen',
                53: 'M√§√üiger Nieselregen',
                55: 'Starker Nieselregen',
                56: 'Gefrierender leichter Nieselregen',
                57: 'Gefrierender starker Nieselregen',
                61: 'Leichter Regen',
                63: 'M√§√üiger Regen',
                65: 'Starker Regen',
                66: 'Leichter gefrierender Regen',
                67: 'Starker gefrierender Regen',
                71: 'Leichter Schneefall',
                73: 'M√§√üiger Schneefall',
                75: 'Starker Schneefall',
                77: 'Schneegriesel',
                80: 'Leichte Regenschauer',
                81: 'M√§√üige Regenschauer',
                82: 'Starke Regenschauer',
                85: 'Leichte Schneeschauer',
                86: 'Starke Schneeschauer',
                95: 'Leichtes Gewitter',
                96: 'Leichtes Gewitter mit Hagel',
                99: 'Starkes Gewitter mit Hagel'
            };
            
            return detailedCodes[code] || 'Unbekannte Wetterlage';
        }

        // Deutsche Wetterbeschreibungen f√ºr Empfehlungen
        const WEATHER_DESCRIPTIONS_DE = {
            'sonnig': {
                short: 'Sonnig',
                long: 'Viel Sonnenschein, ideale Bedingungen f√ºr Solaranlagen',
                impact: 'sehr g√ºnstig',
                recommendation: 'Perfekt f√ºr Solarstrom und g√ºnstige Preise'
            },
            'teilweise bew√∂lkt': {
                short: 'Teilweise bew√∂lkt',
                long: 'Wechselnd bew√∂lkt mit sonnigen Abschnitten',
                impact: 'g√ºnstig',
                recommendation: 'Gute Solarausbeute m√∂glich'
            },
            'bew√∂lkt': {
                short: 'Bew√∂lkt',
                long: 'Dichte Bew√∂lkung, wenig Sonneneinstrahlung',
                impact: 'normal',
                recommendation: 'Durchschnittliche Strompreise erwartet'
            },
            'stark bew√∂lkt': {
                short: 'Stark bew√∂lkt',
                long: 'Geschlossene Wolkendecke, keine Sonne',
                impact: 'erh√∂ht',
                recommendation: 'Preise tendenziell h√∂her durch weniger Solarstrom'
            },
            'Regen': {
                short: 'Regen',
                long: 'Anhaltender Niederschlag',
                impact: 'erh√∂ht',
                recommendation: 'H√∂herer Verbrauch durch Innenaktivit√§ten'
            },
            'Nieselregen': {
                short: 'Nieselregen',
                long: 'Leichter, feiner Niederschlag',
                impact: 'leicht erh√∂ht',
                recommendation: 'Leicht erh√∂hter Innenverbrauch'
            },
            'Schnee': {
                short: 'Schnee',
                long: 'Schneefall bei kalten Temperaturen',
                impact: 'stark erh√∂ht',
                recommendation: 'Hohe Heizlast, Spitzenverbrauch erwartet'
            },
            'Gewitter': {
                short: 'Gewitter',
                long: 'Elektrische Entladungen mit Niederschlag',
                impact: 'variabel',
                recommendation: 'Netzbelastung m√∂glich, Preise k√∂nnen schwanken'
            },
            'windig': {
                short: 'Windig',
                long: 'Starke Winde',
                impact: 'g√ºnstig',
                recommendation: 'Gute Windkraftausbeute senkt Preise'
            },
            'Nebel': {
                short: 'Nebel',
                long: 'Eingeschr√§nkte Sicht durch Bodennebel',
                impact: 'normal',
                recommendation: 'Normale Verbrauchsmuster'
            }
        };

        // Wetter-Anzeige aktualisieren
        function updateWeatherDisplay() {
            const weatherDisplay = document.getElementById('weatherDisplay');
            const weatherText = document.getElementById('weatherText');
            const weatherDetails = document.getElementById('weatherDetails');
            const weatherIcon = document.getElementById('weatherIcon');
            
            if (!currentWeather.isRealData) {
                weatherIcon.textContent = '‚è≥';
                weatherText.textContent = 'Keine Wetterdaten geladen';
                weatherDetails.textContent = 'Klicken Sie auf "Wetter aktualisieren"';
                return;
            }
            
            const timeStr = currentWeather.lastUpdate 
                ? currentWeather.lastUpdate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })
                : 'Jetzt';
            
            // Deutsche Wetterbeschreibung
            const germanCondition = WEATHER_CONDITIONS[currentWeather.condition] || currentWeather.condition;
            const weatherDesc = WEATHER_DESCRIPTIONS_DE[germanCondition] || {
                short: germanCondition,
                long: germanCondition,
                impact: 'normal',
                recommendation: ''
            };
            
            weatherIcon.textContent = getWeatherIcon(germanCondition);
            weatherText.textContent = `${weatherDesc.short}, ${Math.round(currentWeather.temperature)}¬∞C`;
            
            weatherDetails.innerHTML = `
                <div>üå°Ô∏è ${Math.round(currentWeather.temperature)}¬∞C | ‚òÅÔ∏è ${Math.round(currentWeather.cloudCover)}%</div>
                <div>üí® ${Math.round(currentWeather.windSpeed)} km/h | üåßÔ∏è ${Math.round(currentWeather.rainProbability)}%</div>
                <div style="font-size: 0.8rem; color: #888; margin-top: 5px;">
                    ${weatherDesc.long}
                </div>
                <div style="font-size: 0.75rem; color: #666; margin-top: 3px;">
                    üìç ${currentWeather.location} | ‚è∞ ${timeStr}
                </div>
            `;
            
            // Visuelles Feedback basierend auf Wetter
            weatherDisplay.style.background = getWeatherBackground(germanCondition);
            
            // Zus√§tzliche Empfehlung anzeigen
            if (weatherDesc.recommendation) {
                const recommendation = document.getElementById('recommendationText');
                if (recommendation) {
                    // F√ºge nur hinzu, wenn nicht schon vorhanden
                    if (!recommendation.innerHTML.includes(weatherDesc.recommendation)) {
                        recommendation.innerHTML = `üå§Ô∏è ${weatherDesc.recommendation}<br>` + recommendation.innerHTML;
                    }
                }
            }
        }

        // Deutsche Wetter-Hintergr√ºnde
        function getWeatherBackground(condition) {
            const backgrounds = {
                'sonnig': 'linear-gradient(135deg, #ffeb3b, #ff9800)',
                'klar': 'linear-gradient(135deg, #ffeb3b, #ff9800)',
                'teilweise bew√∂lkt': 'linear-gradient(135deg, #bbdefb, #64b5f6)',
                'bew√∂lkt': 'linear-gradient(135deg, #bdbdbd, #757575)',
                'stark bew√∂lkt': 'linear-gradient(135deg, #9e9e9e, #616161)',
                'Regen': 'linear-gradient(135deg, #90caf9, #1976d2)',
                'Nieselregen': 'linear-gradient(135deg, #bbdefb, #42a5f5)',
                'Schnee': 'linear-gradient(135deg, #e3f2fd, #bbdefb)',
                'Schneefall': 'linear-gradient(135deg, #e3f2fd, #90caf9)',
                'Gewitter': 'linear-gradient(135deg, #673ab7, #311b92)',
                'windig': 'linear-gradient(135deg, #80deea, #00bcd4)',
                'Nebel': 'linear-gradient(135deg, #eeeeee, #bdbdbd)',
                'default': 'linear-gradient(135deg, #e3f2fd, #bbdefb)'
            };
            
            return backgrounds[condition] || backgrounds.default;
        }

        // Alle Berechnungen mit neuem Wetter neu durchf√ºhren
        function recalculateWithWeather(weatherImpact) {
            console.log('Neuberechnung mit Wetter:', weatherImpact);
            
            // 1. Aktuelle Preise neu berechnen (mit Wetterfaktor)
            if (currentPrices && currentPrices.length > 0) {
                const updatedPrices = currentPrices.map(price => ({
                    ...price,
                    price: price.price * weatherImpact.factor,
                    pricePerKWh: price.pricePerKWh * weatherImpact.factor,
                    description: `${price.description} (${weatherImpact.description})`
                }));
                
                currentPrices = updatedPrices;
                displayPriceData(currentPrices, 'today');
            }
            
            // 2. Verbrauchsprofil aktualisieren (wenn Temperatur-Extreme)
            if (currentWeather.temperature < 5 || currentWeather.temperature > 25) {
                adjustConsumptionForTemperature(currentWeather.temperature);
            }
            
            // 3. Empfehlungen aktualisieren
            updateRecommendationsForWeather(weatherImpact);
            
            // 4. Gesamte Optimierung neu berechnen
            calculateOptimization();
        }

        // Verbrauch an Temperatur anpassen
        function adjustConsumptionForTemperature(temperature) {
            const eveningSlider = document.getElementById('eveningConsumption');
            const eveningValue = document.getElementById('eveningValue');
            
            if (temperature < 5) {
                // Sehr kalt = mehr Heizung am Abend
                const newValue = Math.min(8, parseFloat(eveningSlider.value) * 1.3);
                eveningSlider.value = newValue;
                eveningValue.textContent = newValue.toFixed(1) + ' kW';
                showMessage('‚ö†Ô∏è Heizlast erh√∂ht (kaltes Wetter)');
            } else if (temperature > 25) {
                // Sehr warm = mehr K√ºhlung
                const newValue = Math.min(8, parseFloat(eveningSlider.value) * 1.2);
                eveningSlider.value = newValue;
                eveningValue.textContent = newValue.toFixed(1) + ' kW';
                showMessage('‚ö†Ô∏è K√ºhllast erh√∂ht (warmes Wetter)');
            }
            
            generateConsumptionProfile();
        }

        // Empfehlungen f√ºr Wetter aktualisieren
        function updateRecommendationsForWeather(weatherImpact) {
            const recommendation = document.getElementById('recommendationText');
            
            if (!recommendation) return;
            
            let weatherTips = '';
            
            if (weatherImpact.factor < 0.9) {
                weatherTips = `üå§Ô∏è G√ºnstiges Wetter! Strompreise sind ${Math.round((1-weatherImpact.factor)*100)}% niedriger als normal.`;
            } else if (weatherImpact.factor > 1.1) {
                weatherTips = `‚ö†Ô∏è Teures Wetter! Strompreise sind ${Math.round((weatherImpact.factor-1)*100)}% h√∂her als normal.`;
            }
            
            if (currentWeather.cloudCover < 30) {
                weatherTips += `<br>‚òÄÔ∏è Viel Sonne: Ideal f√ºr Solar & g√ºnstige Preise`;
            } else if (currentWeather.cloudCover > 70) {
                weatherTips += `<br>‚òÅÔ∏è Stark bew√∂lkt: Wenig Solar, Preise tendenziell h√∂her`;
            }
            
            if (currentWeather.windSpeed > 25) {
                weatherTips += `<br>üí® Viel Wind: Gute Windkraft-Ausbeute`;
            }
            
            if (currentWeather.rainProbability > 60) {
                weatherTips += `<br>üåßÔ∏è Hohe Regenwahrscheinlichkeit: Mehr Innenverbrauch erwartet`;
            }
            
            recommendation.innerHTML = weatherTips + (recommendation.innerHTML || '');
        }

        // Automatische Wetteraktualisierung
        function startWeatherAutoRefresh() {
            // Aktualisiere alle 30 Minuten
            setInterval(() => {
                if (document.visibilityState === 'visible') {
                    console.log('Automatische Wetteraktualisierung...');
                    loadAndApplyRealWeather();
                }
            }, 30 * 60 * 1000); // 30 Minuten
            
            // Aktualisiere auch bei Tab-Wechsel zur√ºck
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Pr√ºfe ob Wetter √§lter als 1 Stunde
                    const now = new Date();
                    const lastUpdate = currentWeather.lastUpdate;
                    
                    if (!lastUpdate || (now - lastUpdate) > 60 * 60 * 1000) {
                        loadAndApplyRealWeather();
                    }
                }
            });
        }

        // ========================================
        // BESTEHENDE FUNKTIONEN (leicht angepasst)
        // ========================================

        function setupSliders() {
            // Verbrauchs-Slider
            const sliders = [
                { id: 'morningConsumption', valueId: 'morningValue', key: 'morning' },
                { id: 'dayConsumption', valueId: 'dayValue', key: 'day' },
                { id: 'eveningConsumption', valueId: 'eveningValue', key: 'evening' },
                { id: 'nightConsumption', valueId: 'nightValue', key: 'night' }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                element.value = DEFAULT_CONSUMPTION[slider.key];
                valueElement.textContent = element.value + ' kW';
                
                element.addEventListener('input', (e) => {
                    valueElement.textContent = e.target.value + ' kW';
                    DEFAULT_CONSUMPTION[slider.key] = parseFloat(e.target.value);
                });
            });
            
            // Akku-Slider
            document.getElementById('batteryLevel').addEventListener('input', (e) => {
                batteryLevel = parseInt(e.target.value);
                updateBatteryDisplay();
            });
        }

        function updateConsumptionAndCalculate() {
            generateConsumptionProfile();
            calculateOptimization();
            showMessage('‚úÖ Verbrauchsprofil aktualisiert und neu berechnet');
        }

        function generateConsumptionProfile() {
            consumptionProfile = [];
            
            // Holen der aktuellen Werte von den Slidern
            const morning = parseFloat(document.getElementById('morningConsumption').value);
            const day = parseFloat(document.getElementById('dayConsumption').value);
            const evening = parseFloat(document.getElementById('eveningConsumption').value);
            const night = parseFloat(document.getElementById('nightConsumption').value);
            
            for (let hour = 0; hour < 24; hour++) {
                let consumption;
                
                if (hour >= 6 && hour < 9) {
                    consumption = morning;
                } else if (hour >= 9 && hour < 17) {
                    consumption = day;
                } else if (hour >= 17 && hour < 22) {
                    consumption = evening;
                } else {
                    consumption = night;
                }
                
                // Zuf√§llige Variation (¬±20%)
                const variation = 0.8 + Math.random() * 0.4;
                consumption *= variation;
                
                consumptionProfile.push({
                    hour: hour,
                    consumption: parseFloat(consumption.toFixed(2)),
                    time: `${hour.toString().padStart(2, '0')}:00`
                });
            }
            
            // Gesamtverbrauch berechnen
            const totalConsumption = consumptionProfile.reduce((sum, item) => sum + item.consumption, 0);
            document.getElementById('totalDailyConsumption').textContent = totalConsumption.toFixed(1) + ' kWh';
            
            updateConsumptionChart();
        }

        // L√§dt Preisdaten von EPEX Spot √ºber die API von SmartEnery (mit API-Fallback)
        async function loadData(period) {
            showLoading(true);
            document.getElementById('calcStep').textContent = 'Lade EPEX Spot Preise...';
            
            // Zeitgeber f√ºr Fallback
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 5000)
            );
            
            try {
                // Versuche API-Daten zu laden
                const apiPromise = loadFromSmartEnergyAPI(period);
                currentPrices = await Promise.race([apiPromise, timeoutPromise]);
                
                showMessage(`‚úÖ ${currentPrices.length} EPEX Spot Preise geladen`);
                
            } catch (error) {
                console.log('API nicht verf√ºgbar, verwende Simulation:', error.message);
                
                // ORIGINALE FUNKTION als Fallback
                currentPrices = generatePriceData(period);
                
                // Markiere als simuliert
                currentPrices.forEach(p => {
                    p.isRealData = false;
                    p.source = 'simulation';
                    p.description = `EPEX Muster ${p.description}`;
                });
                
                showMessage('‚ÑπÔ∏è Simulierte EPEX-Daten verwendet');
            }
            
            // Gemeinsame Verarbeitung
            displayPriceData(currentPrices, period);
            generateConsumptionProfile();
            calculateOptimization();
            showLoading(false);
        }

        async function loadFromSmartEnergyAPI(period) {
            const proxyUrl = 'https://api.allorigins.win/get?url=';
            const apiUrl = 'https://apis.smartenergy.at/market/v1/price?region=AT';
            
            const response = await fetch(`${proxyUrl}${encodeURIComponent(apiUrl)}`);
            const proxyData = await response.json();
            
            if (!proxyData.contents) {
                throw new Error('Keine Daten vom Proxy');
            }
            
            const apiData = JSON.parse(proxyData.contents);
            
            // Verarbeite 15-Minuten zu st√ºndlichen Daten
            const hourlyData = {};
            apiData.data.forEach(point => {
                const hour = new Date(point.date).getHours();
                if (!hourlyData[hour]) hourlyData[hour] = [];
                hourlyData[hour].push(point.value);
            });
            
            // Erstelle st√ºndliche Preise
            const prices = [];
            for (let hour = 0; hour < 24; hour++) {
                const values = hourlyData[hour] || [];
                const avgPrice = values.length > 0 
                    ? values.reduce((a, b) => a + b, 0) / values.length
                    : null;
                
                prices.push({
                    hour: hour,
                    price: avgPrice ? avgPrice * 10 : 0,
                    pricePerKWh: avgPrice ? parseFloat(avgPrice.toFixed(3)) : 0,
                    time: `${hour.toString().padStart(2, '0')}:00`,
                    description: avgPrice ? 'EPEX Spot' : 'Keine Daten',
                    isRealData: !!avgPrice,
                    dataPoints: values.length
                });
            }
            
            return prices;
        }

        function generatePriceData(period) {
            const weekday = document.getElementById('weekday').value;
            const isWeekend = weekday === '6' || weekday === '0';
            const pattern = isWeekend ? PRICE_PATTERNS.weekend : PRICE_PATTERNS.weekday;
            
            // Dynamischen Wetterfaktor verwenden (statt statischem Select)
            const weatherImpact = calculateWeatherImpact(currentWeather);
            const weatherFactor = weatherImpact.factor;
            
            const prices = [];
            
            for (let hour = 0; hour < 24; hour++) {
                let timeWindow = '';
                for (const [window, data] of Object.entries(pattern)) {
                    const [start, end] = window.split('-').map(Number);
                    if (hour >= start && hour < end) {
                        timeWindow = window;
                        break;
                    }
                }
                
                if (!timeWindow) timeWindow = "00-06";
                
                const baseData = pattern[timeWindow];
                let price = baseData.base;
                
                // REALER Wetter-Einfluss anwenden
                price *= weatherFactor;
                
                // Zus√§tzliche Anpassungen basierend auf spezifischen Wetterdaten
                if (currentWeather.isRealData) {
                    // Temperaturabh√§ngige Anpassung
                    if (currentWeather.temperature < 5 && (hour >= 17 && hour < 22)) {
                        price *= 1.15; // Abendheizung bei K√§lte
                    } else if (currentWeather.temperature > 25 && (hour >= 12 && hour < 18)) {
                        price *= 1.10; // Nachmittagsk√ºhlung bei Hitze
                    }
                    
                    // Bew√∂lkungsabh√§ngige Anpassung
                    if (currentWeather.cloudCover > 80 && (hour >= 9 && hour < 17)) {
                        price *= 1.08; // Wenig Solar am Tag
                    } else if (currentWeather.cloudCover < 30 && (hour >= 9 && hour < 17)) {
                        price *= 0.92; // Viel Solar am Tag
                    }
                }
                
                // Zuf√§llige Variation (¬±8%)
                const randomFactor = 0.96 + Math.random() * 0.08;
                price *= randomFactor;
                
                // Rundung
                price = Math.round(price * 100) / 100;
                
                // Beschreibung mit Wetterinfo
                let description = baseData.description;
                if (currentWeather.isRealData) {
                    description += ` | ${weatherImpact.description}`;
                }
                
                prices.push({
                    hour: hour,
                    price: price,
                    pricePerKWh: price / 10,
                    time: `${hour.toString().padStart(2, '0')}:00`,
                    description: description,
                    timeWindow: timeWindow,
                    weatherFactor: weatherFactor,
                    weatherCondition: currentWeather.condition
                });
            }
            
            return prices;
        }

        function displayPriceData(prices, period) {
            const priceValues = prices.map(p => p.pricePerKWh);
            const avgPrice = priceValues.reduce((a, b) => a + b, 0) / priceValues.length;
            const minPrice = Math.min(...priceValues);
            const maxPrice = Math.max(...priceValues);
            const minHour = priceValues.indexOf(minPrice);
            const maxHour = priceValues.indexOf(maxPrice);
            
            // Statistiken anzeigen
            document.getElementById('avgPrice').textContent = avgPrice.toFixed(2) + ' ct/kWh';
            document.getElementById('avgPriceMWh').textContent = (avgPrice * 10).toFixed(2);
            document.getElementById('bestTime').textContent = prices[minHour].time;
            document.getElementById('bestPrice').textContent = minPrice.toFixed(2);
            document.getElementById('worstTime').textContent = prices[maxHour].time;
            document.getElementById('worstPrice').textContent = maxPrice.toFixed(2);
            document.getElementById('currentAvgPrice').textContent = avgPrice.toFixed(2) + ' ct/kWh';
            
            updatePriceChart(prices);
            updatePriceTable(prices, avgPrice);
        }

        function calculateOptimization() {
            if (currentPrices.length === 0 || consumptionProfile.length === 0) {
                showError('Bitte laden Sie zuerst Preisdaten');
                return;
            }
            
            showLoading(true);
            document.getElementById('calcStep').textContent = 'Analysiere Verbrauch...';
            
            // Simuliere Berechnungsprozess
            setTimeout(() => {
                try {
                    document.getElementById('calcStep').textContent = 'Berechne Kosten...';
                    
                    // 1. Aktuelle Kosten berechnen
                    const currentCostResult = calculateCurrentCost();
                    
                    setTimeout(() => {
                        document.getElementById('calcStep').textContent = 'Finde Optimierungen...';
                        
                        // 2. Optimierte Planung finden
                        const optimizationResult = findOptimizations();
                        
                        setTimeout(() => {
                            document.getElementById('calcStep').textContent = 'Berechne Ersparnis...';
                            
                            // 3. Ergebnisse anzeigen
                            displayAllResults(currentCostResult, optimizationResult);
                            
                            // 4. Letzte Berechnungszeit speichern
                            lastCalculationTime = new Date();
                            document.getElementById('lastCalculation').textContent = 
                                lastCalculationTime.toLocaleTimeString('de-DE');
                            
                            showLoading(false);
                            showSuccessMessage('‚úÖ Optimierung erfolgreich berechnet!');
                            
                        }, 300);
                    }, 300);
                } catch (error) {
                    console.error('Fehler bei Optimierung:', error);
                    showError('Optimierung fehlgeschlagen: ' + error.message);
                    showLoading(false);
                }
            }, 500);
        }

        function calculateCurrentCost() {
            let totalCost = 0;
            let totalConsumption = 0;
            
            for (let i = 0; i < 24; i++) {
                const hourCost = currentPrices[i].pricePerKWh; // ct/kWh
                const hourConsumption = consumptionProfile[i].consumption; // kW
                
                totalCost += hourCost * hourConsumption;
                totalConsumption += hourConsumption;
            }
            
            // Kosten f√ºr verschiebbare Ger√§te hinzuf√ºgen
            const laundryTime = document.getElementById('laundryTime').value;
            const heatpumpMode = document.getElementById('heatpumpMode').value;
            
            let additionalCost = 0;
            
            // Waschmaschine (2.0 kW f√ºr 2 Stunden)
            if (laundryTime === 'morning') {
                additionalCost += currentPrices[7].pricePerKWh * 2.0 * 2; // 07:00 Uhr
            } else if (laundryTime === 'afternoon') {
                additionalCost += currentPrices[14].pricePerKWh * 2.0 * 2; // 14:00 Uhr
            } else if (laundryTime === 'night') {
                additionalCost += currentPrices[22].pricePerKWh * 2.0 * 2; // 22:00 Uhr
            }
            
            // W√§rmepumpe (2.5 kW, je nach Modus)
            if (heatpumpMode === 'continuous') {
                // 8 Stunden Betrieb
                const avgPrice = currentPrices.reduce((sum, p) => sum + p.pricePerKWh, 0) / 24;
                additionalCost += avgPrice * 2.5 * 8;
            } else if (heatpumpMode === 'auto') {
                // 6 Stunden zu g√ºnstigeren Zeiten
                const cheapHours = [...currentPrices].sort((a, b) => a.pricePerKWh - b.pricePerKWh).slice(0, 6);
                additionalCost += cheapHours.reduce((sum, h) => sum + h.pricePerKWh, 0) * 2.5;
            } else if (heatpumpMode === 'eco') {
                // 4 Stunden zu den g√ºnstigsten Zeiten
                const cheapestHours = [...currentPrices].sort((a, b) => a.pricePerKWh - b.pricePerKWh).slice(0, 4);
                additionalCost += cheapestHours.reduce((sum, h) => sum + h.pricePerKWh, 0) * 2.5;
            }
            
            totalCost += additionalCost;
            
            const dailyCost = totalCost / 100; // Umrechnung von ct in ‚Ç¨
            
            // Aktuelle Kosten anzeigen
            document.getElementById('currentDailyCost').textContent = dailyCost.toFixed(2) + ' ‚Ç¨';
            document.getElementById('currentCostDisplay').textContent = dailyCost.toFixed(2) + ' ‚Ç¨';
            
            return {
                dailyCost: dailyCost,
                totalConsumption: totalConsumption,
                additionalCost: additionalCost / 100
            };
        }

        function findOptimizations() {
            const optimizations = {
                laundry: { recommendedTime: null, savings: 0 },
                heatpump: { recommendedHours: [], savings: 0 },
                battery: { chargeTimes: [], savings: 0 },
                shiftable: { recommendations: [] }
            };
            
            // 1. Optimale Waschmaschinen-Zeit finden
            const laundryOptions = [];
            for (let i = 0; i < 24; i++) {
                laundryOptions.push({
                    hour: i,
                    time: currentPrices[i].time,
                    price: currentPrices[i].pricePerKWh,
                    cost: currentPrices[i].pricePerKWh * 2.0 * 2 // 2 kW f√ºr 2 Stunden
                });
            }
            
            laundryOptions.sort((a, b) => a.price - b.price);
            optimizations.laundry.recommendedTime = laundryOptions[0];
            
            // Aktuelle Waschzeit-Kosten berechnen
            const currentLaundryTime = document.getElementById('laundryTime').value;
            let currentLaundryCost = 0;
            if (currentLaundryTime === 'morning') {
                currentLaundryCost = currentPrices[7].pricePerKWh * 2.0 * 2;
            } else if (currentLaundryTime === 'afternoon') {
                currentLaundryCost = currentPrices[14].pricePerKWh * 2.0 * 2;
            } else if (currentLaundryTime === 'night') {
                currentLaundryCost = currentPrices[22].pricePerKWh * 2.0 * 2;
            }
            
            optimizations.laundry.savings = (currentLaundryCost - laundryOptions[0].cost) / 100;
            
            // 2. W√§rmepumpen-Optimierung
            const heatpumpMode = document.getElementById('heatpumpMode').value;
            if (heatpumpMode !== 'none') {
                const sortedHours = [...currentPrices].sort((a, b) => a.pricePerKWh - b.pricePerKWh);
                optimizations.heatpump.recommendedHours = sortedHours.slice(0, 6);
            }
            
            // 3. Akku-Ladeoptimierung
            const batteryCapacity = parseInt(document.getElementById('batteryCapacity').value);
            const chargePower = parseFloat(document.getElementById('chargePower').value);
            const neededCharge = batteryCapacity * ((100 - batteryLevel) / 100);
            const hoursNeeded = Math.ceil(neededCharge / chargePower);
            
            const cheapHours = [...currentPrices]
                .filter(p => p.pricePerKWh < 25)
                .sort((a, b) => a.pricePerKWh - b.pricePerKWh)
                .slice(0, hoursNeeded);
            
            optimizations.battery.chargeTimes = cheapHours;
            
            if (cheapHours.length > 0) {
                const normalPrice = 30; // Durchschnittlicher Preis
                const cheapPrice = cheapHours.reduce((sum, h) => sum + h.pricePerKWh, 0) / cheapHours.length;
                optimizations.battery.savings = (normalPrice - cheapPrice) * neededCharge / 100;
            }
            
            // 4. Verschiebbare Lasten identifizieren
            const highConsumptionHours = consumptionProfile
                .map((c, i) => ({...c, price: currentPrices[i].pricePerKWh}))
                .filter(c => c.consumption > 2.0)
                .sort((a, b) => b.price - a.price); // Teuerste zuerst
            
            const lowPriceHours = [...currentPrices]
                .filter(p => p.pricePerKWh < 20)
                .sort((a, b) => a.pricePerKWh - b.pricePerKWh);
            
            for (let i = 0; i < Math.min(highConsumptionHours.length, lowPriceHours.length); i++) {
                const fromHour = highConsumptionHours[i];
                const toHour = lowPriceHours[i];
                const savings = (fromHour.price - toHour.price) * fromHour.consumption / 100;
                
                if (savings > 0.05) { // Nur wenn Ersparnis > 5 Cent
                    optimizations.shiftable.recommendations.push({
                        from: fromHour.time,
                        to: toHour.time,
                        savings: savings,
                        consumption: fromHour.consumption
                    });
                }
            }
            
            return optimizations;
        }

        function displayAllResults(currentCost, optimizations) {
            // 1. Optimierte Kosten berechnen
            const totalSavings = 
                optimizations.laundry.savings + 
                optimizations.battery.savings +
                optimizations.shiftable.recommendations.reduce((sum, r) => sum + r.savings, 0);
            
            const optimizedCost = Math.max(0, currentCost.dailyCost - totalSavings);
            
            // 2. Ergebnisse anzeigen
            document.getElementById('optimizedCostDisplay').textContent = optimizedCost.toFixed(2) + ' ‚Ç¨';
            document.getElementById('dailySavingsDisplay').textContent = totalSavings.toFixed(2) + ' ‚Ç¨';
            
            const savingsPercent = totalSavings > 0 ? Math.round((totalSavings / currentCost.dailyCost) * 100) : 0;
            document.getElementById('savingsPercent').textContent = savingsPercent + '%';
            document.getElementById('savingsProgress').style.width = Math.min(savingsPercent, 100) + '%';
            
            // 3. Monatliche/J√§hrliche Ersparnis
            const monthlySavings = totalSavings * 30;
            const yearlySavings = totalSavings * 365;
            document.getElementById('monthlySavings').textContent = monthlySavings.toFixed(2) + ' ‚Ç¨';
            document.getElementById('yearlySavings').textContent = yearlySavings.toFixed(2) + ' ‚Ç¨';
            document.getElementById('potentialSavings').textContent = monthlySavings.toFixed(2) + '‚Ç¨/Monat';
            
            // 4. Empfehlungstext
            let recommendationText = '';
            if (optimizations.laundry.recommendedTime) {
                recommendationText += `üß∫ Waschmaschine auf ${optimizations.laundry.recommendedTime.time} Uhr stellen<br>`;
            }
            if (optimizations.battery.chargeTimes.length > 0) {
                const times = optimizations.battery.chargeTimes.map(t => t.time).join(', ');
                recommendationText += `üîã Akku laden: ${times} Uhr<br>`;
            }
            if (optimizations.shiftable.recommendations.length > 0) {
                recommendationText += `‚ö° Verbrauch verschieben (siehe Optimierungstab)<br>`;
            }
            
            document.getElementById('recommendationText').innerHTML = recommendationText || 
                'Keine Optimierung m√∂glich - Preise sind relativ konstant';
            
            // 5. Optimierungs-Aktionen anzeigen
            displayOptimizationActions(optimizations);
            
            // 6. Einspar-Tipps generieren
            generateSavingTips(currentCost, optimizations, totalSavings);
            
            // 7. Vergleichs-Chart aktualisieren
            updateComparisonChart(currentPrices, consumptionProfile);
            
            // 8. G√ºnstigste/Teuerste Verbrauchszeit finden
            findBestWorstConsumptionTimes();
        }

        function displayOptimizationActions(optimizations) {
            let actionsHTML = '';
            let scheduleHTML = '';
            let batteryHTML = '';
            
            // Waschmaschine
            if (optimizations.laundry.savings > 0) {
                actionsHTML += `
                    <div class="result-item">
                        <span class="result-label">üß∫ Waschmaschine:</span>
                        <span class="result-value">${optimizations.laundry.recommendedTime.time} Uhr (spart ${optimizations.laundry.savings.toFixed(2)}‚Ç¨/Tag)</span>
                    </div>
                `;
            }
            
            // Akku
            if (optimizations.battery.savings > 0) {
                const times = optimizations.battery.chargeTimes.map(t => t.time).join(', ');
                actionsHTML += `
                    <div class="result-item">
                        <span class="result-label">üîã Akku laden:</span>
                        <span class="result-value">${times} Uhr (spart ${optimizations.battery.savings.toFixed(2)}‚Ç¨/Tag)</span>
                    </div>
                `;
                
                batteryHTML = `Laden Sie Ihren Akku zwischen ${times} Uhr f√ºr maximale Ersparnis`;
            } else {
                batteryHTML = 'Aktuell keine g√ºnstigen Ladezeiten verf√ºgbar';
            }
            
            // Verschiebbare Lasten
            if (optimizations.shiftable.recommendations.length > 0) {
                actionsHTML += `
                    <div class="result-item">
                        <span class="result-label">‚ö° Verschiebbare Lasten:</span>
                        <span class="result-value">${optimizations.shiftable.recommendations.length} Optimierungen m√∂glich</span>
                    </div>
                `;
                
                scheduleHTML = '<ul style="margin-top: 10px; padding-left: 20px;">';
                optimizations.shiftable.recommendations.forEach(rec => {
                    scheduleHTML += `<li>Verschiebe Verbrauch von ${rec.from} auf ${rec.to} Uhr (spart ${rec.savings.toFixed(2)}‚Ç¨)</li>`;
                });
                scheduleHTML += '</ul>';
            } else {
                scheduleHTML = 'Keine Verschiebungen empfohlen';
            }
            
            document.getElementById('optimizationActions').innerHTML = actionsHTML || 'Keine Optimierungen verf√ºgbar';
            document.getElementById('optimizedSchedule').innerHTML = scheduleHTML;
            document.getElementById('batteryStrategy').innerHTML = batteryHTML;
        }

        function findBestWorstConsumptionTimes() {
            let bestTime = '', worstTime = '';
            let bestPrice = Infinity, worstPrice = 0;
            
            for (let i = 0; i < 24; i++) {
                if (consumptionProfile[i].consumption > 0.5) {
                    const price = currentPrices[i].pricePerKWh;
                    if (price < bestPrice) {
                        bestPrice = price;
                        bestTime = currentPrices[i].time;
                    }
                    if (price > worstPrice) {
                        worstPrice = price;
                        worstTime = currentPrices[i].time;
                    }
                }
            }
            
            document.getElementById('bestConsumptionTime').textContent = bestTime || '-';
            document.getElementById('bestConsumptionPrice').textContent = bestPrice !== Infinity ? bestPrice.toFixed(2) + ' ct/kWh' : '-';
            document.getElementById('worstConsumptionTime').textContent = worstTime || '-';
            document.getElementById('worstConsumptionPrice').textContent = worstPrice !== 0 ? worstPrice.toFixed(2) + ' ct/kWh' : '-';
        }

        function generateSavingTips(currentCost, optimizations, totalSavings) {
            const tips = [];
            
            if (totalSavings > 1.0) {
                tips.push(`Sie k√∂nnen <strong>${totalSavings.toFixed(2)}‚Ç¨ pro Tag</strong> sparen!`);
            }
            
            if (optimizations.laundry.savings > 0.2) {
                tips.push(`Waschmaschine auf ${optimizations.laundry.recommendedTime.time} Uhr stellen spart ${optimizations.laundry.savings.toFixed(2)}‚Ç¨`);
            }
            
            if (optimizations.battery.savings > 0.5) {
                tips.push(`Akku bei niedrigen Preisen laden spart ${optimizations.battery.savings.toFixed(2)}‚Ç¨`);
            }
            
            const expensiveHours = currentPrices.filter(p => p.pricePerKWh > 35).length;
            if (expensiveHours > 4) {
                tips.push(`Vermeiden Sie hohen Verbrauch zwischen 17-20 Uhr (teuerste Zeit)`);
            }
            
            if (currentCost.totalConsumption > 25) {
                tips.push(`Ihr Verbrauch ist √ºberdurchschnittlich hoch - pr√ºfen Sie Standby-Ger√§te`);
            }
            
            document.getElementById('savingTips').innerHTML = tips.map(tip => `‚Ä¢ ${tip}`).join('<br>');
        }

        // Chart-Funktionen
        function updatePriceChart(prices) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (priceChart) priceChart.destroy();
            
            const avgPrice = prices.reduce((sum, p) => sum + p.pricePerKWh, 0) / prices.length;
            
            priceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: prices.map(p => p.time),
                    datasets: [{
                        label: 'Strompreis (ct/kWh)',
                        data: prices.map(p => p.pricePerKWh),
                        backgroundColor: prices.map(p => 
                            p.pricePerKWh < avgPrice * 0.8 ? 'rgba(46, 204, 113, 0.7)' :
                            p.pricePerKWh > avgPrice * 1.2 ? 'rgba(231, 76, 60, 0.7)' :
                            'rgba(52, 152, 219, 0.7)'
                        ),
                        borderColor: prices.map(p => 
                            p.pricePerKWh < avgPrice * 0.8 ? 'rgb(46, 204, 113)' :
                            p.pricePerKWh > avgPrice * 1.2 ? 'rgb(231, 76, 60)' :
                            'rgb(52, 152, 219)'
                        ),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const price = context.parsed.y;
                                    const ctPrice = price / 10;
                                    const hour = context.label;
                                    let recommendation = '';
                                    
                                    if (price < avgPrice * 0.7) recommendation = ' ‚≠ê Sehr g√ºnstig';
                                    else if (price < avgPrice * 0.9) recommendation = ' üëç G√ºnstig';
                                    else if (price > avgPrice * 1.3) recommendation = ' ‚ö†Ô∏è Teuer';
                                    
                                    return `${price.toFixed(2)} ‚Ç¨/MWh (${ctPrice.toFixed(2)} ct/kWh)${recommendation}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Preis (‚Ç¨/MWh)' },
                            ticks: { callback: v => v + ' ‚Ç¨' }
                        }
                    }
                }
            });
        }

        function updateConsumptionChart() {
            const ctx = document.getElementById('consumptionChart').getContext('2d');
            if (consumptionChart) consumptionChart.destroy();
            
            consumptionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: consumptionProfile.map(p => p.time),
                    datasets: [{
                        label: 'Stromverbrauch (kW)',
                        data: consumptionProfile.map(p => p.consumption),
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: { display: true, text: 'Verbrauch (kW)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateComparisonChart(prices, consumption) {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            if (comparisonChart) comparisonChart.destroy();
            
            comparisonChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: prices.map(p => p.time),
                    datasets: [
                        {
                            label: 'Strompreis (ct/kWh)',
                            data: prices.map(p => p.pricePerKWh),
                            borderColor: '#00b894',
                            backgroundColor: 'rgba(0, 184, 148, 0.1)',
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Verbrauch (kW)',
                            data: consumption.map(c => c.consumption * 10),
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Preis (ct/kWh)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Verbrauch (kW)' },
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => (v/10).toFixed(1) }
                        }
                    }
                }
            });
        }

        function updatePriceTable(prices, avgPrice) {
            const tableBody = document.getElementById('priceTableBody');
            tableBody.innerHTML = '';
            
            prices.forEach(item => {
                const diff = ((item.pricePerKWh - avgPrice) / avgPrice * 100);
                const diffText = diff >= 0 ? `+${diff.toFixed(1)}%` : `${diff.toFixed(1)}%`;
                const diffColor = diff > 10 ? '#e74c3c' : diff < -10 ? '#2ecc71' : '#666';
                
                let recommendation = 'Normal';
                if (item.pricePerKWh < avgPrice * 0.8) recommendation = '‚≠ê G√ºnstig';
                if (item.pricePerKWh > avgPrice * 1.2) recommendation = '‚ö†Ô∏è Teuer';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item.time}</td>
                    <td><strong>${item.pricePerKWh.toFixed(2)}</strong> ct/kWh</td>
                    <td style="color: ${diffColor};">${diffText}</td>
                    <td>${recommendation}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        // Akku-Funktionen
        function updateBatteryDisplay() {
            document.getElementById('batteryFill').style.width = batteryLevel + '%';
            document.getElementById('batteryPercent').textContent = batteryLevel + '%';
            document.getElementById('batteryValue').textContent = batteryLevel + '%';
            document.getElementById('batteryLevel').value = batteryLevel;
            
            const fill = document.getElementById('batteryFill');
            if (batteryLevel < 20) fill.style.background = '#e74c3c';
            else if (batteryLevel < 50) fill.style.background = '#f39c12';
            else if (batteryLevel < 80) fill.style.background = '#3498db';
            else fill.style.background = '#2ecc71';
        }

        function chargeBattery(amount) {
            batteryLevel = Math.min(100, batteryLevel + amount);
            updateBatteryDisplay();
            showMessage(`üîã Akku um ${amount}% geladen (jetzt: ${batteryLevel}%)`);
            calculateOptimization();
        }

        function dischargeBattery(amount) {
            if (batteryLevel >= amount) {
                batteryLevel = Math.max(0, batteryLevel - amount);
                updateBatteryDisplay();
                showMessage(`üîå Akku um ${amount}% entladen (jetzt: ${batteryLevel}%)`);
                calculateOptimization();
            } else {
                showMessage('‚ùå Akku hat nicht genug Ladung');
            }
        }

        function setBatteryLevel() {
            const newLevel = prompt('Geben Sie den neuen Akku-Ladestand ein (0-100%):', batteryLevel);
            if (newLevel !== null) {
                const level = parseInt(newLevel);
                if (!isNaN(level) && level >= 0 && level <= 100) {
                    batteryLevel = level;
                    updateBatteryDisplay();
                    calculateOptimization();
                    showMessage(`üîã Akku auf ${level}% gesetzt`);
                } else {
                    showMessage('‚ùå Bitte geben Sie eine Zahl zwischen 0 und 100 ein');
                }
            }
        }

        // Tab-Funktionen
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            document.getElementById(`tab-${tabName}`).style.display = 'block';
            document.querySelector(`button[onclick="showTab('${tabName}')"]`).classList.add('active');
            
            // SPEZIAL-LOGIK F√úR FORECAST-TAB
            if (tabName === 'forecast') {
                // Wenn noch keine Prognose existiert, automatisch generieren
                if (forecastData.length === 0) {
                    setTimeout(() => {
                        if (!isModelTrained) {
                            // Zeige Standard-Prognose
                            generateDefaultForecast();
                            
                            // Info-Meldung anzeigen
                            const forecastContainer = document.getElementById('tab-forecast');
                            const infoDiv = document.createElement('div');
                            infoDiv.className = 'info';
                            infoDiv.style.marginTop = '10px';
                            infoDiv.innerHTML = `
                                <strong>‚ÑπÔ∏è Simulierte Prognose</strong><br>
                                F√ºr eine pr√§zise KI-Prognose klicken Sie auf "KI-Modell trainieren"
                            `;
                            forecastContainer.appendChild(infoDiv);
                            
                        } else if (weatherData) {
                            // Wenn Modell trainiert ist und Wetterdaten existieren, echte Prognose generieren
                            generate3DayForecast();
                        }
                    }, 300);
                }
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showError(msg) {
            const div = document.getElementById('error');
            div.innerHTML = `<strong>‚ö†Ô∏è</strong> ${msg}`;
            div.style.display = 'block';
            setTimeout(() => div.style.display = 'none', 5000);
        }

        function showSuccessMessage(msg) {
            const div = document.getElementById('success');
            div.innerHTML = `<strong>‚úÖ</strong> ${msg}`;
            div.style.display = 'block';
            setTimeout(() => div.style.display = 'none', 3000);
        }

        function showMessage(msg) {
            const tempDiv = document.createElement('div');
            tempDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; 
                background: #00b894; color: white; padding: 15px; 
                border-radius: 10px; z-index: 1000;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            `;
            tempDiv.textContent = msg;
            document.body.appendChild(tempDiv);
            setTimeout(() => tempDiv.remove(), 3000);
        }

        // ========================================
        // KI-PROGNOSE FUNKTIONEN (aus letztem Chat)
        // ========================================

        async function createPredictionModel() {
            console.log('Erstelle KI-Modell...');
            
            const model = tf.sequential();
            
            // Eingabeschicht (4 Features: Stunde, Wochentag, Temperatur, Bew√∂lkung)
            model.add(tf.layers.dense({
                units: 16,
                activation: 'relu',
                inputShape: [4]
            }));
            
            // Versteckte Schichten
            model.add(tf.layers.dense({ units: 8, activation: 'relu' }));
            model.add(tf.layers.dropout({ rate: 0.2 }));
            model.add(tf.layers.dense({ units: 4, activation: 'relu' }));
            
            // Ausgabeschicht (1 Output: Strompreis)
            model.add(tf.layers.dense({ units: 1 }));
            
            // Modell kompilieren
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            predictionModel = model;
            document.getElementById('modelStatus').textContent = 'Bereit zum Trainieren';
            
            return model;
        }

        async function loadWeatherData() {
            showLoading(true);
            document.getElementById('calcStep').textContent = 'Lade Wettervorhersage...';
            
            try {
                // Versuche Standort zu bekommen
                const location = await getLocation();
                
                const params = {
                    latitude: location.latitude,
                    longitude: location.longitude,
                    hourly: 'temperature_2m,cloud_cover,wind_speed_10m,precipitation_probability',
                    timezone: 'Europe/Berlin',
                    forecast_days: 3
                };
                
                const queryString = new URLSearchParams(params).toString();
                const url = `${WEATHER_API.baseUrl}?${queryString}`;
                
                console.log('Lade Wetter von:', url);
                const response = await fetch(url);
                
                if (!response.ok) throw new Error(`Wetter-API: ${response.status}`);
                
                weatherData = await response.json();
                console.log('Wetterdaten erhalten:', weatherData);
                
                // Wetterstatus aktualisieren
                document.getElementById('weatherStatus').textContent = 'Geladen';
                document.getElementById('weatherLocation').textContent = location.name;
                
                // Wetterdaten anzeigen
                displayCurrentWeather();
                
                showMessage(`‚úÖ Wettervorhersage f√ºr ${location.name} geladen`);
                
            } catch (error) {
                console.error('Wetter-Fehler:', error);
                showError('Wetterdaten konnten nicht geladen werden');
                document.getElementById('weatherStatus').textContent = 'Fehlgeschlagen';
            } finally {
                showLoading(false);
            }
        }

        function displayCurrentWeather() {
            if (!weatherData || !weatherData.hourly) return;
            
            const now = new Date();
            const currentHour = now.getHours();
            
            const temp = weatherData.hourly.temperature_2m[currentHour] || 'N/A';
            const clouds = weatherData.hourly.cloud_cover[currentHour] || 'N/A';
            const wind = weatherData.hourly.wind_speed_10m[currentHour] || 'N/A';
            const rain = weatherData.hourly.precipitation_probability[currentHour] || 'N/A';
            
            const weatherHtml = `
                <div class="result-item">
                    <span class="result-label">üå°Ô∏è Aktuelle Temperatur:</span>
                    <span class="result-value">${temp}¬∞C</span>
                </div>
                <div class="result-item">
                    <span class="result-label">‚òÅÔ∏è Bew√∂lkung:</span>
                    <span class="result-value">${clouds}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üí® Windgeschwindigkeit:</span>
                    <span class="result-value">${wind} km/h</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üåßÔ∏è Regenwahrscheinlichkeit:</span>
                    <span class="result-value">${rain}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üìç Standort:</span>
                    <span class="result-value">${currentWeather.location || 'Wien, √ñsterreich'}</span>
                </div>
            `;
            
            document.getElementById('currentWeather').innerHTML = weatherHtml;
        }

        async function collectTrainingData() {
            const trainingData = [];
            const labels = [];
            
            // Simulierte historische Daten
            for (let i = 0; i < 100; i++) {
                const hour = Math.floor(Math.random() * 24);
                const weekday = Math.floor(Math.random() * 7);
                const temperature = 10 + Math.random() * 20;
                const cloudCover = Math.random() * 100;
                
                let basePrice = 25;
                if (hour >= 0 && hour < 6) basePrice = 18;
                else if (hour >= 6 && hour < 9) basePrice = 28;
                else if (hour >= 9 && hour < 17) basePrice = 35;
                else if (hour >= 17 && hour < 21) basePrice = 42;
                else basePrice = 30;
                
                if (temperature > 25) basePrice *= 1.1;
                if (cloudCover < 30) basePrice *= 0.9;
                
                basePrice *= (0.9 + Math.random() * 0.2);
                
                trainingData.push([hour / 23, weekday / 6, temperature / 40, cloudCover / 100]);
                labels.push(basePrice / 50);
            }
            
            return {
                features: tf.tensor2d(trainingData),
                labels: tf.tensor2d(labels, [labels.length, 1])
            };
        }

        async function trainPredictionModel() {
            if (isTraining) {
                showMessage('‚ö†Ô∏è Training l√§uft bereits');
                return;
            }
            
            showTrainingModal();
            
            try {
                if (!predictionModel) {
                    await createPredictionModel();
                }
                
                // Training vorbereiten
                document.getElementById('trainingStatus').textContent = 'Bereite Daten vor...';
                addTrainingLog('Starte Datenvorbereitung...');
                
                const trainingData = await collectTrainingData();
                addTrainingLog(`Daten generiert: ${trainingData.features.shape[0]} Samples`);
                
                // Training starten
                const totalEpochs = 50;
                const history = {
                    epoch: [],
                    history: {
                        loss: [],
                        val_loss: []
                    }
                };
                
                const trainingResult = await predictionModel.fit(trainingData.features, trainingData.labels, {
                    epochs: totalEpochs,
                    batchSize: 10,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: async (epoch, logs) => {
                            // ... bestehende onEpochEnd Logik ...
                        },
                        onTrainEnd: async (logs) => {
                            addTrainingLog('Training abgeschlossen');
                            
                            // MODIFIZIERT: Nach Training automatisch Prognose generieren
                            if (!stopTrainingRequested) {
                                isModelTrained = true;
                                
                                // Modal schlie√üen
                                hideTrainingModal();
                                
                                // Erfolgsmeldung
                                showMessage('‚úÖ KI-Modell erfolgreich trainiert!');
                                
                                // Automatisch Prognose generieren
                                setTimeout(async () => {
                                    try {
                                        await generate3DayForecast();
                                        showMessage('üìä KI-Prognose automatisch generiert!');
                                        
                                        // Zum Forecast-Tab wechseln
                                        showTab('forecast');
                                    } catch (forecastError) {
                                        console.error('Automatische Prognose fehlgeschlagen:', forecastError);
                                        showMessage('‚ö†Ô∏è Prognose konnte nicht automatisch generiert werden');
                                    }
                                }, 500);
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Training-Fehler:', error);
                addTrainingLog(`FEHLER: ${error.message}`);
                
                hideTrainingModal();
                showError('KI-Modell konnte nicht trainiert werden: ' + error.message);
            } finally {
                isTraining = false;
                stopTrainingRequested = false;
            }
        }

        // Deutsche Wetterempfehlungen f√ºr Prognose-Tab
        function getGermanWeatherAdvice(weatherData) {
            if (!weatherData) return '';
            
            const { temperature, cloudCover, windSpeed, rainProbability, condition } = weatherData;
            const germanCondition = WEATHER_CONDITIONS[condition] || condition;
            
            let advice = [];
            
            // Temperatur-basierte Empfehlungen
            if (temperature < 0) {
                advice.push('‚ùÑÔ∏è Frostwarnung: Hohe Heizlast erwartet');
            } else if (temperature < 5) {
                advice.push('ü•∂ Sehr kalt: Erh√∂hte Heizkosten');
            } else if (temperature > 28) {
                advice.push('ü•µ Hitzewarnung: K√ºhlungsbedarf steigt');
            } else if (temperature > 22) {
                advice.push('‚òÄÔ∏è Warm: Moderate K√ºhlung n√∂tig');
            }
            
            // Bew√∂lkungs-basierte Empfehlungen
            if (cloudCover < 20) {
                advice.push('‚òÄÔ∏è Viel Sonne: Optimale Solarausbeute');
            } else if (cloudCover < 50) {
                advice.push('‚õÖ Leicht bew√∂lkt: Gute Solarertr√§ge');
            } else if (cloudCover > 80) {
                advice.push('‚òÅÔ∏è Stark bew√∂lkt: Geringe Solarleistung');
            }
            
            // Wind-basierte Empfehlungen
            if (windSpeed > 30) {
                advice.push('üí® Starker Wind: Hohe Windkraftausbeute');
            } else if (windSpeed > 15) {
                advice.push('üçÉ M√§√üiger Wind: Gute Windkraft');
            }
            
            // Regen-basierte Empfehlungen
            if (rainProbability > 70) {
                advice.push('üåßÔ∏è Viel Regen: Mehr Innenverbrauch');
            } else if (rainProbability > 30) {
                advice.push('üå¶Ô∏è Regen m√∂glich: Leicht erh√∂hter Verbrauch');
            }
            
            // Wettertyp-spezifische Empfehlungen
            if (germanCondition.includes('Gewitter')) {
                advice.push('‚ö° Gewitter: Netzstabilit√§t k√∂nnte beeintr√§chtigt sein');
    }
    if (germanCondition.includes('Nebel')) {
        advice.push('üå´Ô∏è Nebel: Normale Verbrauchsmuster');
    }
    if (germanCondition.includes('Schnee')) {
        advice.push('‚ùÑÔ∏è Schnee: Sehr hohe Heizlast');
    }
    
    return advice.length > 0 
        ? `<strong>Wetterempfehlung:</strong><br>‚Ä¢ ${advice.join('<br>‚Ä¢ ')}`
        : 'Normales Wetter: Standard-Verbrauchsmuster erwartet';
}

        async function generate3DayForecast() {
            showLoading(true);
            document.getElementById('calcStep').textContent = 'Generiere KI-Prognose...';
            
            try {
                // Pr√ºfe Voraussetzungen
                if (!predictionModel) {
                    throw new Error('KI-Modell nicht initialisiert');
                }
                
                if (!weatherData) {
                    throw new Error('Keine Wetterdaten verf√ºgbar');
                }
                
                forecastData = [];
                const now = new Date();
                
                for (let dayOffset = 0; dayOffset < 3; dayOffset++) {
                    for (let hour = 0; hour < 24; hour++) {
                        const targetDate = new Date(now);
                        targetDate.setDate(targetDate.getDate() + dayOffset);
                        targetDate.setHours(hour, 0, 0, 0);
                        
                        const weekday = targetDate.getDay();
                        const dataIndex = dayOffset * 24 + hour;
                        
                        const temperature = weatherData.hourly.temperature_2m[dataIndex] || 15;
                        const cloudCover = weatherData.hourly.cloud_cover[dataIndex] || 50;
                        
                        // KI-Vorhersage (falls Modell trainiert)
                        let predictedPrice;
                        if (isModelTrained) {
                            const features = tf.tensor2d([[
                                hour / 23,
                                weekday / 6,
                                temperature / 40,
                                cloudCover / 100
                            ]]);
                            
                            const prediction = predictionModel.predict(features);
                            predictedPrice = (await prediction.data())[0] * 50;
                            
                            features.dispose();
                            prediction.dispose();
                        } else {
                            // Fallback: Simulierte Preise
                            predictedPrice = 25 + Math.random() * 20;
                        }
                        
                        // Wetterkorrekturen
                        let finalPrice = predictedPrice;
                        
                        if (cloudCover < 20) finalPrice *= 0.85;
                        if (cloudCover > 80) finalPrice *= 1.15;
                        if (temperature < 0) finalPrice *= 1.2;
                        if (temperature > 28) finalPrice *= 1.15;
                        if (weekday === 0 || weekday === 6) finalPrice *= 0.8;
                        
                        forecastData.push({
                            dayOffset: dayOffset,
                            hour: hour,
                            date: targetDate,
                            predictedPrice: finalPrice,
                            temperature: temperature,
                            cloudCover: cloudCover,
                            windSpeed: weatherData.hourly.wind_speed_10m[dataIndex] || 10,
                            rainProb: weatherData.hourly.precipitation_probability[dataIndex] || 0,
                            weekday: weekday,
                            isSimulated: !isModelTrained
                        });
                    }
                }
                
                // Ergebnisse anzeigen
                displayForecast();
                updateForecastChart();
                findBestBuyTime();
                
                // Status aktualisieren
                if (isModelTrained) {
                    document.getElementById('modelStatus').textContent = 'Trained ‚úì';
                    document.getElementById('forecastAccuracy').textContent = 'Berechne...';
                    
                    // Genauigkeit automatisch pr√ºfen
                    setTimeout(() => {
                        analyzeForecastAccuracy();
                    }, 1000);
                }
                
                showMessage(`‚úÖ ${isModelTrained ? 'KI-' : ''}Prognose f√ºr 3 Tage generiert!`);
                
            } catch (error) {
                console.error('Prognose-Fehler:', error);
                
                // Fallback zu Standard-Prognose
                generateDefaultForecast();
                showMessage('‚ö†Ô∏è KI-Prognose fehlgeschlagen, verwende Standard-Prognose');
                
            } finally {
                showLoading(false);
            }
        }

        function displayForecast() {
            if (forecastData.length === 0) {
                document.getElementById('forecastDetails').innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #666;">
                        <div style="font-size: 2rem; margin-bottom: 10px;">ü§ñ</div>
                        <div style="margin-bottom: 15px;"><strong>Keine Prognose verf√ºgbar</strong></div>
                        <button onclick="generateDefaultForecast()" style="margin: 5px; padding: 10px 20px;">
                            üìä Standard-Prognose anzeigen
                        </button>
                        <button onclick="trainPredictionModel()" style="margin: 5px; padding: 10px 20px; background: #00b894;">
                            ü§ñ KI-Modell trainieren
                        </button>
                    </div>
                `;
                return;
            }
            
            // Gruppiere nach Tag
            const days = [[], [], []];
            forecastData.forEach(item => {
                if (item.dayOffset < 3) {
                    days[item.dayOffset].push(item);
                }
            });
            
            let forecastHtml = '';
            
            // Header mit Statusinfo
            const hasSimulatedData = forecastData.some(item => item.isSimulated);
            if (hasSimulatedData) {
                forecastHtml += `
                    <div class="info" style="margin-bottom: 15px;">
                        <strong>‚ÑπÔ∏è ${isModelTrained ? 'KI-' : 'Simulierte'} Prognose</strong><br>
                        ${isModelTrained ? 'Basierend auf trainiertem KI-Modell' : 'Basierend auf typischen Preisverl√§ufen'}
                    </div>
                `;
            }
            
            days.forEach((dayData, dayIndex) => {
                if (dayData.length === 0) return;
                
                const date = dayData[0].date;
                const avgPrice = dayData.reduce((sum, item) => sum + item.predictedPrice, 0) / dayData.length;
                const minPrice = Math.min(...dayData.map(item => item.predictedPrice));
                const maxPrice = Math.max(...dayData.map(item => item.predictedPrice));
                const minHour = dayData.find(item => item.predictedPrice === minPrice).hour;
                const maxHour = dayData.find(item => item.predictedPrice === maxPrice).hour;
                
                // Empfehlungs-Icon basierend auf Preisniveau
                let recommendationIcon = 'üí∞';
                if (avgPrice < 25) recommendationIcon = '‚≠ê';
                else if (avgPrice > 40) recommendationIcon = '‚ö†Ô∏è';
                
                forecastHtml += `
                    <div class="forecast-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h5 style="margin: 0;">${recommendationIcon} ${date.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' })}</h5>
                            <span style="background: ${avgPrice < 25 ? '#2ecc71' : avgPrice > 40 ? '#e74c3c' : '#f39c12'}; 
                                color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.9rem;">
                                √ò ${avgPrice.toFixed(1)} ct/kWh
                            </span>
                        </div>
                        
                        <div class="result-item">
                            <span class="result-label">üìâ G√ºnstigste Stunde:</span>
                            <span class="result-value">${minHour.toString().padStart(2, '0')}:00 (${minPrice.toFixed(1)} ct)</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">üìà Teuerste Stunde:</span>
                            <span class="result-value">${maxHour.toString().padStart(2, '0')}:00 (${maxPrice.toFixed(1)} ct)</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">üå§Ô∏è Mittleres Wetter:</span>
                            <span class="result-value">
                                ${dayData[12].temperature.toFixed(1)}¬∞C, 
                                ${dayData[12].cloudCover}% bew√∂lkt
                            </span>
                        </div>
                        
                        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
                            <div style="font-size: 0.9rem; color: #666;">
                                ${getGermanWeatherAdvice({
                                    temperature: dayData[12].temperature,
                                    cloudCover: dayData[12].cloudCover,
                                    windSpeed: dayData[12].windSpeed,
                                    rainProbability: dayData[12].rainProb,
                                    condition: getConditionFromCode(dayData[12].weatherCode)
                                })}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('forecastDetails').innerHTML = forecastHtml;
        }

        // Konvertiert Wettercode zu deutscher Beschreibung
        function getConditionFromCode(code) {
            const codeMap = {
                0: 'sonnig',
                1: 'teilweise bew√∂lkt',
                2: 'teilweise bew√∂lkt',
                3: 'bew√∂lkt',
                45: 'Nebel',
                48: 'Nebel',
                51: 'Nieselregen',
                53: 'Nieselregen',
                55: 'Nieselregen',
                61: 'Regen',
                63: 'Regen',
                65: 'Regen',
                71: 'Schnee',
                73: 'Schnee',
                75: 'Schnee',
                80: 'Regenschauer',
                81: 'Regenschauer',
                82: 'Regenschauer',
                85: 'Schneeschauer',
                86: 'Schneeschauer',
                95: 'Gewitter',
                96: 'Gewitter',
                99: 'Gewitter'
            };
            
            return codeMap[code] || 'unbekannt';
        }

        // Hilfsfunktion f√ºr Empfehlungen
        function getForecastRecommendation(avgPrice, bestHour, worstHour) {
            if (avgPrice < 25) {
                return `G√ºnstiger Tag! Ideal f√ºr hohen Verbrauch und Akku-Ladung.`;
            } else if (avgPrice > 40) {
                return `Teurer Tag! Verbrauch auf ${bestHour}:00 Uhr verschieben.`;
            } else {
                return `Normales Preisniveau. Akku zwischen ${bestHour}:00-${worstHour}:00 Uhr laden.`;
            }
        }

        function updateForecastChart() {
            const ctx = document.getElementById('forecastChart').getContext('2d');
            if (forecastChart) forecastChart.destroy();
            
            const labels = forecastData.map(item => 
                `${item.date.getDate()}.${item.date.getMonth() + 1} ${item.hour.toString().padStart(2, '0')}:00`
            );
            
            const prices = forecastData.map(item => item.predictedPrice);
            
            const colors = prices.map(price => {
                const avg = prices.reduce((a, b) => a + b, 0) / prices.length;
                if (price < avg * 0.8) return 'rgba(46, 204, 113, 0.7)';
                if (price < avg) return 'rgba(52, 152, 219, 0.7)';
                if (price > avg * 1.2) return 'rgba(231, 76, 60, 0.7)';
                return 'rgba(241, 196, 15, 0.7)';
            });
            
            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'KI-Prognose (ct/kWh)',
                            data: prices,
                            borderColor: '#9b59b6',
                            backgroundColor: 'rgba(155, 89, 182, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Durchschnitt',
                            data: Array(prices.length).fill(prices.reduce((a, b) => a + b, 0) / prices.length),
                            borderColor: '#7f8c8d',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: { display: true, text: 'Prognostizierter Preis (ct/kWh)' },
                            beginAtZero: false
                        },
                        x: {
                            ticks: {
                                maxTicksLimit: 24,
                                callback: function(value, index) {
                                    return index % 6 === 0 ? this.getLabelForValue(value) : '';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = forecastData[context.dataIndex];
                                    return [
                                        `Preis: ${context.raw.toFixed(2)} ct/kWh`,
                                        `Uhrzeit: ${item.hour}:00`,
                                        `Temperatur: ${item.temperature.toFixed(1)}¬∞C`,
                                        `Bew√∂lkung: ${item.cloudCover}%`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Deutsche Wettervorhersage f√ºr mehrere Tage
        function displayGermanWeatherForecast() {
            if (!weatherData || !weatherData.daily) return;
            
            let forecastHTML = '<h4>üìÖ 7-Tage Wettervorhersage</h4>';
            
            weatherData.daily.time.forEach((dateStr, index) => {
                if (index >= 7) return; // Nur 7 Tage
                
                const date = new Date(dateStr);
                const dayName = date.toLocaleDateString('de-DE', { weekday: 'long' });
                const maxTemp = Math.round(weatherData.daily.temperature_2m_max[index]);
                const minTemp = Math.round(weatherData.daily.temperature_2m_min[index]);
                const weatherCode = weatherData.daily.weather_code[index];
                const condition = interpretWeatherCodeDetailed(weatherCode);
                const icon = getWeatherIcon(condition, true);
                
                forecastHTML += `
                    <div style="display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee;">
                        <div style="font-size: 1.5rem; margin-right: 10px;">${icon}</div>
                        <div style="flex: 1;">
                            <div><strong>${dayName}</strong></div>
                            <div style="font-size: 0.9rem; color: #666;">${condition}</div>
                        </div>
                        <div style="text-align: right;">
                            <div><strong>${maxTemp}¬∞</strong> / ${minTemp}¬∞</div>
                            <div style="font-size: 0.8rem; color: #888;">${date.getDate()}.${date.getMonth() + 1}.</div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('weatherForecastDetails').innerHTML = forecastHTML;
        }

        function findBestBuyTime() {
            if (forecastData.length === 0) return;
            
            const sortedByPrice = [...forecastData].sort((a, b) => a.predictedPrice - b.predictedPrice);
            const bestTimes = sortedByPrice.slice(0, 3);
            
            document.getElementById('bestBuyTime').textContent = 
                `${bestTimes[0].hour.toString().padStart(2, '0')}:00`;
            document.getElementById('bestBuyPrice').textContent = 
                `${bestTimes[0].predictedPrice.toFixed(2)} ct/kWh`;
            
            const recommendation = document.getElementById('recommendationText');
            if (recommendation) {
                recommendation.innerHTML += `<br>ü§ñ KI-Empfehlung: Laden Sie zwischen ${bestTimes[0].hour}:00-${bestTimes[2].hour}:00 Uhr`;
            }
        }

        async function analyzeForecastAccuracy() {
            if (forecastData.length === 0) {
                showError('Bitte zuerst Prognose generieren');
                return;
            }
            
            try {
                const currentPrices = await loadCurrentEPEXData();
                
                if (!currentPrices || currentPrices.length < 24) {
                    throw new Error('Nicht genug aktuelle Daten zum Vergleich');
                }
                
                let totalError = 0;
                let count = 0;
                
                for (let i = 0; i < 24 && i < currentPrices.length; i++) {
                    const forecastItem = forecastData.find(item => item.dayOffset === 0 && item.hour === i);
                    if (forecastItem && currentPrices[i]) {
                        const error = Math.abs(forecastItem.predictedPrice - currentPrices[i].pricePerKWh);
                        totalError += error;
                        count++;
                    }
                }
                
                const avgError = totalError / count;
                const accuracy = Math.max(0, 100 - (avgError * 10));
                
                document.getElementById('forecastAccuracy').textContent = `${accuracy.toFixed(1)} %`;
                
                showMessage(`‚úÖ Prognose-Genauigkeit: ${accuracy.toFixed(1)}% (Durchschn. Fehler: ${avgError.toFixed(2)} ct/kWh)`);
                
            } catch (error) {
                console.error('Genauigkeitspr√ºfung fehlgeschlagen:', error);
                showError('Genauigkeit konnte nicht gepr√ºft werden');
            }
        }

        async function loadCurrentEPEXData() {
            try {
                const proxyUrl = 'https://api.allorigins.win/get?url=';
                const apiUrl = 'https://apis.smartenergy.at/market/v1/price?region=AT';
                
                const response = await fetch(`${proxyUrl}${encodeURIComponent(apiUrl)}`);
                const proxyData = await response.json();
                
                if (proxyData.contents) {
                    const apiData = JSON.parse(proxyData.contents);
                    return processToHourly(apiData.data || []);
                }
            } catch (error) {
                console.error('Fehler beim Laden aktueller Daten:', error);
            }
            return null;
        }

        function processToHourly(dataPoints) {
            const hourlyData = {};
            
            dataPoints.forEach(point => {
                const hour = new Date(point.date).getHours();
                if (!hourlyData[hour]) hourlyData[hour] = [];
                hourlyData[hour].push(point.value);
            });
            
            const prices = [];
            for (let hour = 0; hour < 24; hour++) {
                const values = hourlyData[hour] || [];
                const avgPrice = values.length > 0 
                    ? values.reduce((a, b) => a + b, 0) / values.length
                    : null;
                
                if (avgPrice) {
                    prices.push({
                        hour: hour,
                        pricePerKWh: avgPrice
                    });
                }
            }
            
            return prices;
        }

        // Globale Variablen f√ºr Training
        let trainingChart = null;
        let trainingLogs = [];
        let isTraining = false;
        let trainingStartTime = null;
        let stopTrainingRequested = false;

        // Mobile-optimierte Training-Funktionen
        let miniChartData = [];

        // Training-Modal Funktionen
        function showTrainingModal() {
            const modal = document.getElementById('trainingModal');
            modal.style.display = 'flex';
            
            // F√ºr Mobile: Verhindere Hintergrund-Scroll
            document.body.style.overflow = 'hidden';
            
            isTraining = true;
            stopTrainingRequested = false;
            trainingStartTime = new Date();
            trainingLogs = [];
            miniChartData = [];
            
            updateTrainingLogs();
            updateMiniChart();
            
            // Zeige "Schlie√üen"-Button nur nach Training
            document.getElementById('closeTrainingBtn').style.display = 'none';
        }

        function hideTrainingModal() {
            const modal = document.getElementById('trainingModal');
            modal.style.display = 'none';
            
            // Erlaube wieder Scroll
            document.body.style.overflow = '';
        }

        // Vereinfachte Mini-Chart f√ºr Mobile
        function updateMiniChart() {
            const container = document.getElementById('trainingMiniChart');
            if (!container) return;
            
            if (miniChartData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Chart wird geladen...</div>';
                return;
            }
            
            const maxLoss = Math.max(...miniChartData);
            const minLoss = Math.min(...miniChartData);
            const range = maxLoss - minLoss || 1;
            const barWidth = 100 / miniChartData.length;
            
            let chartHTML = '<div style="display: flex; align-items: flex-end; height: 100%; gap: 2px;">';
            
            miniChartData.forEach((loss, index) => {
                const height = 70 - ((loss - minLoss) / range) * 65; // 5-70px H√∂he
                const color = loss < (maxLoss * 0.3) ? '#2ecc71' : 
                            loss < (maxLoss * 0.6) ? '#f39c12' : '#e74c3c';
                
                chartHTML += `
                    <div class="training-chart-bar" 
                        style="width: ${barWidth}%; height: ${height}%; background: ${color};"
                        title="Epoche ${index + 1}: ${loss.toFixed(4)}">
                    </div>
                `;
            });
            
            chartHTML += '</div>';
            container.innerHTML = chartHTML;
        }

        function stopTraining() {
            stopTrainingRequested = true;
            showMessage('‚ö†Ô∏è Training wird abgebrochen...');
        }

        function updateTrainingLogs() {
            const logsContainer = document.getElementById('trainingLogs');
            logsContainer.innerHTML = trainingLogs
                .map(log => `<div class="training-log-entry">${log}</div>`)
                .join('');
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        function addTrainingLog(message) {
            const time = new Date().toLocaleTimeString('de-DE', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            // K√ºrze lange Nachrichten f√ºr Mobile
            let shortMessage = message;
            if (message.length > 60) {
                shortMessage = message.substring(0, 57) + '...';
            }
            
            trainingLogs.push(`[${time}] ${shortMessage}`);
            
            // Begrenze auf 10 Eintr√§ge f√ºr Mobile
            if (trainingLogs.length > 10) {
                trainingLogs.shift();
            }
            
            updateTrainingLogs();
        }

        function updateTrainingChart(history) {
            const ctx = document.getElementById('trainingChart').getContext('2d');
            
            if (trainingChart) trainingChart.destroy();
            
            const epochs = Array.from({length: history.epoch.length}, (_, i) => i + 1);
            
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: epochs,
                    datasets: [
                        {
                            label: 'Training Loss',
                            data: history.history.loss,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            tension: 0.3
                        },
                        {
                            label: 'Validation Loss',
                            data: history.history.val_loss || Array(epochs.length).fill(null),
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Loss (logarithmisch)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Epoche'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        }
                    }
                }
            });
        }

        function calculateTimeRemaining(currentEpoch, totalEpochs, startTime) {
            if (currentEpoch <= 1) return 'Berechne...';
            
            const now = new Date();
            const elapsed = now - startTime;
            const timePerEpoch = elapsed / currentEpoch;
            const remainingEpochs = totalEpochs - currentEpoch;
            const remainingMs = timePerEpoch * remainingEpochs;
            
            if (remainingMs < 1000) return '< 1 Sekunde';
            if (remainingMs < 60000) return `${Math.ceil(remainingMs / 1000)} Sekunden`;
            if (remainingMs < 3600000) return `${Math.ceil(remainingMs / 60000)} Minuten`;
            
            const hours = Math.floor(remainingMs / 3600000);
            const minutes = Math.ceil((remainingMs % 3600000) / 60000);
            return `${hours}h ${minutes}m`;
        }

        // √úberarbeitete trainPredictionModel Funktion
        async function trainPredictionModel() {
            if (isTraining) {
                showMessage('‚ö†Ô∏è Training l√§uft bereits');
                return;
            }
            
            showTrainingModal();
            
            try {
                if (!predictionModel) {
                    await createPredictionModel();
                }
                
                // Training vorbereiten
                document.getElementById('trainingStatus').textContent = 'Bereite Daten vor...';
                document.getElementById('trainingDetail').textContent = 'Generiere Trainingsdaten...';
                addTrainingLog('Starte Datenvorbereitung...');
                
                const trainingData = await collectTrainingData();
                addTrainingLog(`Daten generiert: ${trainingData.features.shape[0]} Samples`);
                
                // Training starten
                document.getElementById('trainingStatus').textContent = 'Training l√§uft...';
                
                const totalEpochs = 50;
                const history = {
                    epoch: [],
                    history: {
                        loss: [],
                        val_loss: []
                    }
                };
                
                const trainingResult = await predictionModel.fit(trainingData.features, trainingData.labels, {
                    epochs: totalEpochs,
                    batchSize: 10,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochBegin: async (epoch, logs) => {
                            if (stopTrainingRequested) {
                                addTrainingLog('Training abgebrochen vom Benutzer');
                                predictionModel.stopTraining = true;
                            }
                        },
                        onEpochEnd: async (epoch, logs) => {
                            const currentEpoch = epoch + 1;
                            
                            // Update UI
                            document.getElementById('currentEpoch').textContent = `${currentEpoch}/${totalEpochs}`;
                            document.getElementById('currentLoss').textContent = logs.loss.toFixed(4);
                            document.getElementById('currentMAE').textContent = logs.mae ? logs.mae.toFixed(4) : '-';
                            
                            const progress = (currentEpoch / totalEpochs) * 100;
                            document.getElementById('trainingProgressBar').style.width = `${progress}%`;
                            
                            const timeRemaining = calculateTimeRemaining(currentEpoch, totalEpochs, trainingStartTime);
                            document.getElementById('timeRemaining').textContent = timeRemaining;
                            
                            document.getElementById('trainingDetail').textContent = 
                                `Epoche ${currentEpoch}/${totalEpochs} - Loss: ${logs.loss.toFixed(4)}`;
                            
                            // History speichern
                            history.epoch.push(currentEpoch);
                            history.history.loss.push(logs.loss);
                            if (logs.val_loss) history.history.val_loss.push(logs.val_loss);
                            
                            // Chart aktualisieren (alle 5 Epochen)
                            if (currentEpoch % 5 === 0 || currentEpoch === totalEpochs) {
                                updateTrainingChart(history);
                            }
                            
                            // Log hinzuf√ºgen
                            const logMsg = `Epoche ${currentEpoch}: Loss=${logs.loss.toFixed(4)}, Val=${logs.val_loss ? logs.val_loss.toFixed(4) : 'N/A'}`;
                            addTrainingLog(logMsg);
                            
                            // Alle 10 Epochen Status speichern
                            if (currentEpoch % 10 === 0) {
                                console.log(logMsg);
                            }
                        },
                        onTrainEnd: async (logs) => {
                            addTrainingLog('Training abgeschlossen');
                        }
                    }
                });
                
                if (!stopTrainingRequested) {
                    // Training erfolgreich abgeschlossen
                    isModelTrained = true;
                    
                    document.getElementById('modelStatus').textContent = 'Trained ‚úì';
                    document.getElementById('modelAccuracy').textContent = 
                        `Loss: ${trainingResult.history.loss[trainingResult.history.loss.length - 1].toFixed(4)}`;
                    
                    const modelDetails = `
                        <div class="result-item">
                            <span class="result-label">üèãÔ∏è Trainingsepochs:</span>
                            <span class="result-value">${totalEpochs}</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">üìâ Finaler Loss:</span>
                            <span class="result-value">${trainingResult.history.loss[trainingResult.history.loss.length - 1].toFixed(4)}</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">üß† Modell-Architektur:</span>
                            <span class="result-value">4-16-8-4-1 Neuronen</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">‚öôÔ∏è Optimizer:</span>
                            <span class="result-value">Adam (0.001)</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">‚è±Ô∏è Trainingszeit:</span>
                            <span class="result-value">${((new Date() - trainingStartTime) / 1000).toFixed(1)}s</span>
                        </div>
                    `;
                    
                    document.getElementById('modelDetails').innerHTML = modelDetails;
                    
                    // Finales Chart anzeigen
                    updateTrainingChart({
                        epoch: Array.from({length: totalEpochs}, (_, i) => i + 1),
                        history: trainingResult.history
                    });
                    
                    // Modal schlie√üen nach kurzer Anzeige
                    setTimeout(() => {
                        hideTrainingModal();
                        showMessage('‚úÖ KI-Modell erfolgreich trainiert!');
                    }, 2000);
                    
                } else {
                    // Training abgebrochen
                    hideTrainingModal();
                    showMessage('‚ö†Ô∏è Training wurde abgebrochen');
                }
                
            } catch (error) {
                console.error('Training-Fehler:', error);
                addTrainingLog(`FEHLER: ${error.message}`);
                
                setTimeout(() => {
                    hideTrainingModal();
                    showError('KI-Modell konnte nicht trainiert werden: ' + error.message);
                }, 1000);
            } finally {
                isTraining = false;
                stopTrainingRequested = false;
            }
        }

        // Mobile-optimierte Trainingsfunktion
        async function trainPredictionModelMobile() {
            if (isTraining) {
                showMessage('‚ö†Ô∏è Training l√§uft bereits');
                return;
            }
            
            showTrainingModal();
            
            try {
                if (!predictionModel) {
                    await createPredictionModel();
                }
                
                // Training vorbereiten
                updateTrainingUI('Bereite Daten vor...', 'Generiere Trainingsdaten...', 0);
                addTrainingLog('Starte Datenvorbereitung...');
                
                const trainingData = await collectTrainingData();
                addTrainingLog(`${trainingData.features.shape[0]} Samples`);
                
                // Training starten
                const totalEpochs = 50;
                let currentEpoch = 0;
                
                const trainingResult = await predictionModel.fit(trainingData.features, trainingData.labels, {
                    epochs: totalEpochs,
                    batchSize: 10,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochBegin: async (epoch, logs) => {
                            if (stopTrainingRequested) {
                                addTrainingLog('Training abgebrochen');
                                predictionModel.stopTraining = true;
                            }
                        },
                        onEpochEnd: async (epoch, logs) => {
                            currentEpoch = epoch + 1;
                            
                            // Speichere Loss f√ºr Chart
                            miniChartData.push(logs.loss);
                            if (miniChartData.length > 20) miniChartData.shift();
                            
                            // Update UI
                            updateTrainingUI(
                                `Training Epoche ${currentEpoch}/${totalEpochs}`,
                                `Loss: ${logs.loss.toFixed(4)}${logs.val_loss ? ` | Val: ${logs.val_loss.toFixed(4)}` : ''}`,
                                (currentEpoch / totalEpochs) * 100
                            );
                            
                            // Update Stats
                            document.getElementById('currentEpoch').textContent = `${currentEpoch}/${totalEpochs}`;
                            document.getElementById('currentLoss').textContent = logs.loss.toFixed(4);
                            
                            // Zeitberechnung f√ºr Mobile (vereinfacht)
                            if (trainingStartTime) {
                                const elapsed = (new Date() - trainingStartTime) / 1000;
                                const remaining = ((totalEpochs - currentEpoch) * (elapsed / currentEpoch)).toFixed(0);
                                document.getElementById('timeRemaining').textContent = `${remaining}s`;
                                document.getElementById('trainingSpeed').textContent = `${(currentEpoch / elapsed).toFixed(1)}/s`;
                            }
                            
                            // Log
                            addTrainingLog(`E${currentEpoch}: L=${logs.loss.toFixed(4)}`);
                            
                            // Chart aktualisieren (nicht zu oft f√ºr Performance)
                            if (currentEpoch % 5 === 0) {
                                updateMiniChart();
                            }
                        },
                        onTrainEnd: async (logs) => {
                            if (!stopTrainingRequested) {
                                // Training erfolgreich
                                isModelTrained = true;
                                
                                updateTrainingUI(
                                    'Training abgeschlossen!',
                                    `Finaler Loss: ${trainingResult.history.loss[trainingResult.history.loss.length - 1].toFixed(4)}`,
                                    100
                                );
                                
                                addTrainingLog('‚úÖ Training erfolgreich');
                                
                                // Zeige "Schlie√üen"-Button
                                document.getElementById('closeTrainingBtn').style.display = 'block';
                                
                                // Automatisch nach 3 Sekunden schlie√üen
                                setTimeout(() => {
                                    hideTrainingModal();
                                    showMessage('‚úÖ KI-Modell trainiert!');
                                    
                                    // Automatisch Prognose generieren
                                    setTimeout(() => {
                                        generate3DayForecast();
                                        showTab('forecast');
                                    }, 500);
                                }, 3000);
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Training-Fehler:', error);
                
                updateTrainingUI(
                    'Fehler beim Training',
                    error.message.substring(0, 50) + '...',
                    0
                );
                
                addTrainingLog(`FEHLER: ${error.message}`);
                
                // Zeige "Schlie√üen"-Button bei Fehler
                document.getElementById('closeTrainingBtn').style.display = 'block';
                
            } finally {
                if (stopTrainingRequested) {
                    isTraining = false;
                    hideTrainingModal();
                    showMessage('‚ö†Ô∏è Training abgebrochen');
                }
            }
        }

        // Hilfsfunktion f√ºr UI-Updates
        function updateTrainingUI(status, detail, progress) {
            const statusEl = document.getElementById('trainingStatus');
            const detailEl = document.getElementById('trainingDetail');
            const progressBar = document.getElementById('trainingProgressBar');
            
            if (statusEl) statusEl.textContent = status;
            if (detailEl) detailEl.textContent = detail;
            if (progressBar) progressBar.style.width = `${progress}%`;
        }

        // Alternative: Vereinfachte Version ohne Chart
        function trainPredictionModelSimple() {
            if (isTraining) {
                showMessage('‚ö†Ô∏è Training l√§uft bereits');
                return;
            }
            
            showTrainingModal();
            const totalEpochs = 50;
            
            // Simuliertes Training f√ºr Demo
            let currentEpoch = 0;
            const trainingInterval = setInterval(() => {
                if (stopTrainingRequested || currentEpoch >= totalEpochs) {
                    clearInterval(trainingInterval);
                    
                    if (stopTrainingRequested) {
                        hideTrainingModal();
                        showMessage('‚ö†Ô∏è Training abgebrochen');
                    } else {
                        // Training "abgeschlossen"
                        isModelTrained = true;
                        document.getElementById('modelStatus').textContent = 'Trained ‚úì';
                        
                        setTimeout(() => {
                            hideTrainingModal();
                            showMessage('‚úÖ KI-Modell erfolgreich trainiert!');
                        }, 1000);
                    }
                    isTraining = false;
                    return;
                }
                
                currentEpoch++;
                const progress = (currentEpoch / totalEpochs) * 100;
                const fakeLoss = 0.5 * Math.exp(-currentEpoch / 20) + 0.01 * Math.random();
                
                // Update UI
                document.getElementById('currentEpoch').textContent = `${currentEpoch}/${totalEpochs}`;
                document.getElementById('currentLoss').textContent = fakeLoss.toFixed(4);
                document.getElementById('trainingProgressBar').style.width = `${progress}%`;
                document.getElementById('trainingStatus').textContent = `Training Epoche ${currentEpoch}...`;
                
                addTrainingLog(`Epoche ${currentEpoch}: Loss=${fakeLoss.toFixed(4)}`);
                
            }, 200); // 200ms pro Epoche = 10 Sekunden Gesamt
        }

        // Alternative: Super einfache Version f√ºr sehr alte Ger√§te
        function trainPredictionModelSimpleMobile() {
            if (isTraining) {
                showMessage('‚ö†Ô∏è Training l√§uft bereits');
                return;
            }
            
            showTrainingModal();
            const totalEpochs = 30; // Weniger Epochen f√ºr Mobile
            
            // Simuliertes Training
            let currentEpoch = 0;
            const trainingInterval = setInterval(() => {
                if (stopTrainingRequested || currentEpoch >= totalEpochs) {
                    clearInterval(trainingInterval);
                    
                    if (!stopTrainingRequested) {
                        // "Training abgeschlossen"
                        isModelTrained = true;
                        updateTrainingUI('Training abgeschlossen!', 'KI-Modell ist bereit', 100);
                        addTrainingLog('‚úÖ Training erfolgreich');
                        
                        // Zeige Schlie√üen-Button
                        document.getElementById('closeTrainingBtn').style.display = 'block';
                        
                        // Automatisch schlie√üen nach 2 Sekunden
                        setTimeout(() => {
                            hideTrainingModal();
                            showMessage('‚úÖ KI-Modell trainiert!');
                            
                            // Automatisch Prognose generieren
                            generateDefaultForecast();
                            showTab('forecast');
                        }, 2000);
                    } else {
                        hideTrainingModal();
                        showMessage('‚ö†Ô∏è Training abgebrochen');
                    }
                    
                    isTraining = false;
                    return;
                }
                
                currentEpoch++;
                const progress = (currentEpoch / totalEpochs) * 100;
                const fakeLoss = 0.5 * Math.exp(-currentEpoch / 10) + 0.02 * Math.random();
                
                // Update UI
                updateTrainingUI(
                    `Training l√§uft...`,
                    `Epoche ${currentEpoch}/${totalEpochs}`,
                    progress
                );
                
                document.getElementById('currentEpoch').textContent = `${currentEpoch}/${totalEpochs}`;
                document.getElementById('currentLoss').textContent = fakeLoss.toFixed(4);
                
                // Mini-Chart
                miniChartData.push(fakeLoss);
                if (miniChartData.length > 15) miniChartData.shift();
                updateMiniChart();
                
                // Log
                addTrainingLog(`E${currentEpoch}: L=${fakeLoss.toFixed(4)}`);
                
            }, 300); // Langsamer f√ºr bessere Sichtbarkeit
        }

        // Event-Listener f√ºr Touch-Ger√§te
        document.addEventListener('DOMContentLoaded', () => {
            // ... bestehende Initialisierung ...
            
            // Touch-Optimierung f√ºr Modal
            const modal = document.getElementById('trainingModal');
            if (modal) {
                // Verhindere Modal-Schlie√üen bei Touch im Content
                modal.addEventListener('touchstart', (e) => {
                    if (e.target === modal) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Swipe-down to close (optional)
                let startY;
                modal.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                });
                
                modal.addEventListener('touchmove', (e) => {
                    if (!startY) return;
                    
                    const currentY = e.touches[0].clientY;
                    const diff = currentY - startY;
                    
                    // Wenn nach unten geswiped wird, Modal schlie√üen
                    if (diff > 100 && !isTraining) {
                        hideTrainingModal();
                    }
                });
            }
        });

    </script>
</body>
</html>
